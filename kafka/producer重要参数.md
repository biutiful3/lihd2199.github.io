### 重要参数

------

buffer.memory：生产者可以用来缓冲等待发送到服务器的记录的总内存字节

> 如果记录被发送的速度超过了它们可以被发送到服务器的速度，那么生产者将阻塞max.block。然后它会抛出一个异常。

batch.size：指定ProducerBatch可以复用的内存区域大小

> 当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算（而不是消息个数）。当批次被填满，批次里的所有消息会被发送出去。不过生产者并不一定都会等到批次被填满才发送。所以就算把批次大小设置得很大，也不会造成延迟，只是会占用更多的内存而已。但如果设置得太小，因为生产者需要更频繁地发送消息，会增加一些额外的开销。

linger.ms：生产者发送 ProducerBatch 之前等待更多消息（ProducerRecord）加入ProducerBatch 的时间

> 该参数指定了生产者在发送批次之前等待更多消息加入批次的时间。KafkaProducer会在批次填满或linger.ms达到上限时把批次发送出去。默认情况下，只要有可用的线程，生产者就会把消息发送出去，就算批次里只有一个消息。把linger.ms设置成比0大的数，让生产者在发送批次之前等待一会儿，使更多的消息加入到这个批次。虽然这样会增加延迟，但也会提升吞吐量（因为一次性发送更多的消息，每个消息的开销就变小了）。

ack：指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的

> acks=1，生产者发送消息之后，只要分区的leader副本成功写入消息，那么它就会收到来自服务端的成功响应。
>
> acks=0，生产者发送消息之后不需要等待任何服务端的响应
>
> acks=-1或acks=all，生产者在消息发送之后，需要等待ISR中的所有副本都成功写入消息之后才能够收到来自服务端的成功响应
>
> acks参数配置的值是一个字符串类型，而不是整数类型

max.request.size：这个参数用来限制生产者客户端能发送的消息的最大值，默认值为 1048576B，即 1MB

> 不建议读者盲目地增大这个参数的配置值，这个参数还涉及一些其他参数的联动，比如broker端的message.max.bytes参数，如果配置错误可能会引起一些不必要的异常

retries：配置生产者重试的次数，默认值为0，即在发生异常的时候不进行任何重试动作

retry.backoff.ms：默认值为100，它用来设定两次重试之间的时间间隔，避免无效的频繁重试

> 并不是所有的异常都是可以通过重试来解决的，比如消息太大，超过max.request.size参数配置的值时
>
> 配置 retries 和 retry.backoff.ms之前，最好先估算一下可能的异常恢复时间，这样可以设定总的重试时间大于这个异常恢复时间，以此来避免生产者过早地放弃重试

max.in.flight.requests.per.connection：限制客户端在单个连接上能够发送的未响应请求的个数，可以避免消息乱序

> 如果将acks参数配置为非零值，并且max.in.fight.requests.per.connection参数配置为大于1的值，那么就会出现错序的现象：如果第一批次消息写入失败，而第二批次消息写入成功，那么生产者会重试发送第一批次的消息，此时如果第一批次的消息写入成功，那么这两个批次的消息就出现了错序。一般而言，在需要保证消息顺序的场合建议把参数max.in.fight.requests.per.connection配置为1，而不是把acks配置为0，不过这样也会影响整体的吞吐。

compression.type：指定消息的压缩方式，默认值为“none”，即默认情况下，消息不会被压缩。该参数还可以配置为“gzip”“snappy”和“lz4”。

connections.max.idle.ms：指定在多久之后关闭限制的连接，默认值是540000（ms），即9分钟。

request.timeout.ms：Producer等待请求响应的最长时间，默认值为30000（ms）。

> 请求超时之后可以选择进行重试。注意这个参数需要比broker端参数replica.lag.time.max.ms的值要大，这样可以减少因客户端重试而引起的消息重复的概率。

max.block.ms：控制prodecer中的 send()方法可以阻塞的时间


副本才是真实存储消息的物理存在，实际上，每个副本都是以日志（Log）的形式存储消息的。为了解决单一日志文件过大的问题，kafka采用了日志分段（LogSegment）的形式进行存储。所谓日志分段，就是当一个日志文件大小到达一定条件之后，就新建一个新的日志分段，然后在新的日志分段写入数据。

![](./img/log.png)

为了加快消息的检索，每个日志分段除了真实的数据日志文件(`.log`后缀)之外，还有对应的2个索引文件：偏移量索引文件(`.index`)和时间戳索引文件(`.timeindex`)

每个日志分段都有一个基准偏移量（baseOffset，20位数字），表示当前日志分段的第一条消息的offset。日志分段相关文件名就用基准偏移量进行命名

```
00000000000000000000.log 
00000000000000000000.index 
00000000000000000000.timeindex 
00000000000000000133.log 
00000000000000000133.index 
00000000000000000133.timeindex
```

![](./img/log2.png)

日志分段文件包括了2个索引文件：偏移量索引文件和时间戳索引文件。其中，偏移量索引文件用来建立消息偏移量与物理地址之间的映射关系，时间戳索引文件则是用来建立时间戳与偏移量的映射关系。偏移量索引文件中的偏移量是单调递增的，是以稀疏索引的方式构建的。索引并不是连续的，这样索引文件可以更小，查找更快。

根据偏移量索引查找消息过程如下：

> 1. 使用二分法快速定位偏移量索引文件。因为文件名就是baseOffset，所以可以快速定位到该文件。
> 2. 使用二分法快速定位索引项。具体来说就是在索引文件中找到小于当前偏移量的最大偏移量的索引项。
> 3. 从上一步中索引项的物理地址开始，顺序查找出对应偏移量的消息。

时间戳索引项每个索引项占用12个字节，分为两部分：

> 1. timestamp：当前日志分段的最大时间戳。
> 2. relativeOffset：时间戳对应消息的相对偏移量。

根据时间戳查找对应消息的过程如下：

> 1. 根据时间戳到每个日志分段文件中最大的时间戳逐一比较，定位到时间戳索引文件。因为时间戳索引文件也是使用了baseOffset命名，所以没办法直接通过二分法快速定位到。
> 2. 使用二分法快速定位时间戳索引项。
> 3. 根据上一步中的偏移量，通过偏移量索引查出对应的消息。



Kafka将消息存在磁盘中，为了控制占用磁盘空间不断增加，Kafka支持了日志清理功能。kafka提供了两种日志清理策略：

> 1. 日志删除（Log Retention）：按照一定的保留策略直接删除不符合条件的日志分段。
> 2. 日志压缩（Log Compaction）：针对每个消息的key进行整合，对于相同key的不同value值，只保留最后一个版本。

Kafka会周期性的检测并删除不符合保留条件的日志分段文件。这个周期可以通过broker端参数`log.tetention.check.interval.ms`配置，默认5分钟。当前日志分段的保留策略有三种：基于时间的保留策略、基于日志大小的保留策略和基于日志起始偏移量的保留策略。

基于时间

> 日志删除任务会检查当前日志文件保留时间超过设置阈值的日志分段集合，然后对应的所有文件加上`.deleted`后缀，最后由一个延迟任务来删除这些文件。阈值可以通过broker端参数`log.retention.ms`、`log.retention.minutes`和`log.retention.hours`设置，默认是7天。

基于日志大小

> 日志删除任务会检查当前**日志大小超过设置阈值**的日志分段集合，然后对应的所有文件加上`.deleted`后缀，最后由一个延迟任务来删除这些文件。阈值可以通过broker端参数`log.retention.bytes`设置，默认值为-1，表示无穷大。

基于日志起始偏移量

> 日志删除任务会检查当前日志分段的下一个日志分段的`baseOffset`小于等于`logStartOffset`的日志分段集合，然后对应的所有文件加上`.deleted`后缀，最后由一个延迟任务来删除这些文件。

日志压缩

> 日志压缩是在默认日志删除规则之外提供的一种清理数据的方式。日志压缩对于相同key的不同value值，只保留最后一个版本。

顺序写盘

> 实际上，顺序写盘的性能并不差，是随机写盘的6000倍以上。kafka在设计时采用了文件追加的方式来写入消息，就是使用了顺序写盘来保证高性能。

页缓存

> 页缓存是操作系统支持的磁盘缓存，以此来减少磁盘`I/O`操作。简单来说，就是操作系统基于页为单位把磁盘中的热点数据缓存在内存中，进而将大量的`I/O`操作转换为内存操作，大大提高了整体性能。kafka中大量使用了页缓存，消息都是先写入页缓存中，然后才由操作系统写入到磁盘中。

零拷贝

> 零拷贝是指将数据直接从磁盘文件复制到网卡设备中，不需要经过应用程序。零拷贝大大提高了应用程序的性能，减少了内核和用户模式的上下文切换。kafka采用了零拷贝技术来进一步提升性能。
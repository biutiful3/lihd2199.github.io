<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>定风波 on China No. 1</title>
    <link>https://lihd2199.github.io/</link>
    <description>Recent content in 定风波 on China No. 1</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>lihongda</copyright>
    <lastBuildDate>Mon, 30 Aug 2021 19:47:57 +0800</lastBuildDate>
    
        <atom:link href="https://lihd2199.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>704-二分查找</title>
      <link>https://lihd2199.github.io/post/leetcode/704/</link>
      <pubDate>Tue, 07 Sep 2021 10:26:41 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/leetcode/704/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/binary-search/&#34;&gt;704. 二分查找 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;两种解题方案：&lt;/p&gt;
&lt;p&gt;一、循环&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; nums&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; low &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; high &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;low &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; high&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;high &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; low&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;min&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;min&lt;span style=&#34;color:#f92672&#34;&gt;])&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            high &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            low &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;二、递归&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; nums&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; helper&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; nums&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; left&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; right&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;left&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;right&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; right&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; left&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;index&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; index&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;index&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; helper&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; left&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; helper&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; right&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>linux内核前言（四）Io与网络模型</title>
      <link>https://lihd2199.github.io/post/linux/io%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 06 Sep 2021 20:44:10 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/linux/io%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
      
        <description>&lt;h3 id=&#34;常见的io模型介绍&#34;&gt;常见的io模型介绍：&lt;/h3&gt;
&lt;p&gt;阻塞 &amp;amp; 非阻塞&lt;/p&gt;
&lt;p&gt;多路复用&lt;/p&gt;
&lt;p&gt;Signal IO&lt;/p&gt;
&lt;p&gt;异步 IO&lt;/p&gt;
&lt;p&gt;libevent&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>linux内核前言（四）Linux并发工具</title>
      <link>https://lihd2199.github.io/post/linux/linux%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 06 Sep 2021 20:33:30 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/linux/linux%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/</guid>
      
        <description>&lt;h3 id=&#34;linux内核针对不同并发场景的工具实现&#34;&gt;Linux内核针对不同并发场景的工具实现&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/Linux%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;atomic-原子变量&#34;&gt;atomic 原子变量&lt;/h4&gt;
&lt;p&gt;x86在多核环境下，多核竞争数据总线时，提供Lock指令进行锁总线操作。保证“读-修改-写”的操作在芯片级的原子性。&lt;/p&gt;
&lt;h4 id=&#34;spinlock-自旋锁&#34;&gt;spinlock 自旋锁&lt;/h4&gt;
&lt;p&gt;自旋锁将当前线程不停地执行循环体，而不改变线程的运行状态，在CPU上实现忙等，以此保证响应速度更快。这种类型的线程数不断增加时，性能明显下降。所以自旋锁保护的临界区必须小，操作过程必须短。&lt;/p&gt;
&lt;h4 id=&#34;semaphore-信号量&#34;&gt;semaphore 信号量&lt;/h4&gt;
&lt;p&gt;信号量用于保护有限数量的临界资源，信号量在获取和释放时，通过自旋锁保护，当有中断会把中断保存到eflags寄存器，最后再恢复中断。&lt;/p&gt;
&lt;h4 id=&#34;mutex-互斥锁&#34;&gt;mutex 互斥锁&lt;/h4&gt;
&lt;p&gt;为了控制同一时刻只有一个线程进入临界区，让无法进入临界区的线程休眠。&lt;/p&gt;
&lt;h4 id=&#34;rw-lock-读写锁&#34;&gt;rw-lock 读写锁&lt;/h4&gt;
&lt;p&gt;读写锁，把读操作和写操作分别进行加锁处理，减小了加锁粒度，优化了读大于写的场景。&lt;/p&gt;
&lt;h4 id=&#34;preempt-抢占&#34;&gt;preempt 抢占&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;时间片用完后调用schedule函数。&lt;/li&gt;
&lt;li&gt;由于IO等原因自己主动调用schedule。&lt;/li&gt;
&lt;li&gt;其他情况，当前进程被其他进程替换的时候。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;per-cpu-变量&#34;&gt;per-cpu 变量&lt;/h4&gt;
&lt;p&gt;linux为解决cpu 各自使用的L2 cache 数据与内存中的不一致的问题。&lt;/p&gt;
&lt;h4 id=&#34;内存屏障-memory-barrier&#34;&gt;内存屏障 memory-barrier&lt;/h4&gt;
&lt;p&gt;程序运行过程中，对内存访问不一定按照代码编写的顺序来进行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译器对代码进行优化。&lt;/li&gt;
&lt;li&gt;多cpu架构存在指令乱序访问内存的可能。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>linux内核前言（三）cpu缓存相关</title>
      <link>https://lihd2199.github.io/post/linux/cpu%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</link>
      <pubDate>Sun, 05 Sep 2021 21:21:00 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/linux/cpu%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</guid>
      
        <description>&lt;h3 id=&#34;cpu缓存的意义&#34;&gt;CPU缓存的意义&lt;/h3&gt;
&lt;p&gt;　　CPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令CPU能在CPU缓存中找到，CPU就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。所以，缓存的意义满足以下两种局部性原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。&lt;/li&gt;
&lt;li&gt;空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpu三级缓存结构&#34;&gt;CPU三级缓存结构&lt;/h3&gt;
&lt;p&gt;　　计算机在运行过程中，CPU与存储器之间的数据交换最为频繁。CPU是计算机中速度最快的部件，而存储器的工作速度要低于CPU，这就意味着，CPU读取存储器中的数据需要有等待过程。计算机科学家研究发现，如果把要执行的程序代码和数据先行调入CPU暂存，就能提高CPU的运行效率。为此设计者在CPU内部开辟出一个存储区域，用于存放将要执行的程序代码，它和CPU以相同的速度运行。这个CPU内部存储器叫做高速缓存器（Cache）。&lt;/p&gt;
&lt;p&gt;　　在CPU内的那一部分存储器叫做L1缓存（Level 1 Cache）。后来在CPU外部和存储器之间也使用了一种速度快于存储器但稍慢于CPU的L2缓存（Level 2Cache）。最新的CPU技术将L1、L2缓存都设计在CPU芯片内，外置的是L3缓存（Level 3 Cache）。缓存对CPU的运行效率有直接影响，对各级缓存的调度也是由CPU负责完成的。　　&lt;/p&gt;
&lt;p&gt;　　三级缓存的结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/cpu%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/0voice/linux_kernel_wiki/blob/main/%E6%96%87%E7%AB%A0/%E6%B5%85%E8%B0%88Linux%E5%86%85%E6%A0%B8%E4%B9%8BCPU%E7%BC%93%E5%AD%98.md&#34;&gt;原图链接&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L1缓存分成两种，一种是指令缓存，一种是数据缓存。L2缓存和L3缓存不分指令和数据；&lt;/li&gt;
&lt;li&gt;L1和L2缓存在每一个CPU核中，L3则是所有CPU核心共享的内存；&lt;/li&gt;
&lt;li&gt;L1、L2、L3的越离CPU近就越小，速度也越快；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;带有高速缓存cpu执行计算的流程&#34;&gt;带有高速缓存CPU执行计算的流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;程序以及数据被加载到主内存&lt;/li&gt;
&lt;li&gt;指令和数据被加载到CPU的高速缓存&lt;/li&gt;
&lt;li&gt;CPU执行指令，把结果写到高速缓存&lt;/li&gt;
&lt;li&gt;高速缓存中的数据写回主内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpu缓存一致性协议mesi&#34;&gt;CPU缓存一致性协议(MESI)&lt;/h3&gt;
&lt;p&gt;　　MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的支持写回策略的缓存一致性协议。为了保证多个CPU缓存中共享数据的一致性，定义了缓存行(Cache Line)的四种状态，而CPU对缓存行的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的缓存行的状态进行一致性修改，从而保证数据在多个缓存之间保持一致性。&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&#34;https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE&#34;&gt;MESI的维基百科&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;mesi定义的四种状态&#34;&gt;MESI定义的四种状态&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;监听任务&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;M（修改）modified&lt;/td&gt;
&lt;td&gt;缓存行是脏的（&lt;em&gt;dirty&lt;/em&gt;），与主存的值不同。&lt;/td&gt;
&lt;td&gt;缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E（互斥）exclusive&lt;/td&gt;
&lt;td&gt;该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。&lt;/td&gt;
&lt;td&gt;缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S（共享）shared&lt;/td&gt;
&lt;td&gt;该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。&lt;/td&gt;
&lt;td&gt;缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I（无效）invalid&lt;/td&gt;
&lt;td&gt;缓存行是无效的&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
&lt;strong&gt;对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的&lt;/strong&gt;。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。&lt;/p&gt;
&lt;h3 id=&#34;多核缓存协同操作&#34;&gt;多核缓存协同操作&lt;/h3&gt;
&lt;p&gt;假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、 c。在主内存中定义了x的引用值为0。&lt;/p&gt;
&lt;h4 id=&#34;双核读取执行流程&#34;&gt;双核读取执行流程：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;CPU A发出了一条指令，从主内存中读取x;&lt;/li&gt;
&lt;li&gt;CPU A从主内存通过bus读取到 cache a中并将该cache line 设置为E状态;&lt;/li&gt;
&lt;li&gt;CPU B发出了一条指令，从主内存中读取x;&lt;/li&gt;
&lt;li&gt;CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x 存储于cache a和cache b中，x在chche a和cache b中都被设置为S状态(共享);&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;修改数据执行流程&#34;&gt;修改数据执行流程：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;CPU A 计算完成后发指令需要修改x;&lt;/li&gt;
&lt;li&gt;CPU A 将x设置为M状态（修改）并通知缓存了x的CPU B, CPU B将本地cache b中的x设置为I状态(无效);&lt;/li&gt;
&lt;li&gt;CPU A 对x进行赋值;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;同步数据执行流程&#34;&gt;同步数据执行流程：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;CPU B 发出了要读取x的指令;&lt;/li&gt;
&lt;li&gt;CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）;&lt;/li&gt;
&lt;li&gt;CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内存屏障memory-barrier&#34;&gt;内存屏障（Memory barrier）&lt;/h3&gt;
&lt;h4 id=&#34;为什么会有内存屏障&#34;&gt;为什么会有内存屏障&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。&lt;/li&gt;
&lt;li&gt;用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存屏障是什么&#34;&gt;内存屏障是什么&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;硬件层的内存屏障分为两种：&lt;code&gt;Load Barrier&lt;/code&gt; 和 &lt;code&gt;Store Barrier&lt;/code&gt;即读屏障和写屏障。&lt;/li&gt;
&lt;li&gt;内存屏障有两个作用：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;阻止屏障两侧的指令重排序；&lt;/li&gt;
&lt;li&gt;强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；&lt;/li&gt;
&lt;li&gt;对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2ab5e3d7e510&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;乱序执行&#34;&gt;乱序执行&lt;/h3&gt;
&lt;p&gt;　　乱序执行（out-of-orderexecution）：是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。这样将根据各电路单元的状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路。&lt;/p&gt;
&lt;p&gt;　　这好比请A、B、C三个名人为晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字。如果这时在一张大纸上按顺序由A写好”春节”后再交给B写”联欢”，然后再由C写”晚会”，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。&lt;/p&gt;
&lt;p&gt;　　但如果采用三个人分别用三张纸同时写的做法， 那么B和C都不必须等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就象乱序执行），但当他们都写完后就必须重新在横幅上（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）按”春节联欢晚会”的顺序排好才能挂出去。&lt;/p&gt;
&lt;p&gt;　　所以，CPU 为什么会有乱序执行优化？本质原因是CPU为了效率，将长费时的操作“异步”执行，排在后面的指令不等前面的指令执行完毕就开始执行后面的指令。而且允许排在前面的长费时指令后于排在后面的指令执行完。&lt;/p&gt;
&lt;p&gt;CPU 执行乱序主要有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写写乱序(store store)&lt;/strong&gt;：a=1;b=2; -&amp;gt; b=2;a=1;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写读乱序(store load)&lt;/strong&gt;：a=1;load(b); -&amp;gt; load(b);a=1;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读读乱序(load load)&lt;/strong&gt;：load(a);load(b); -&amp;gt; load(b);load(a);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读写乱序(load store)&lt;/strong&gt;：load(a);b=2; -&amp;gt; b=2;load(a);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之，CPU的乱序执行优化指的是处理器为提高运算速度而做出违背代码原有顺序的优化。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>linux内核前言（二）linux内核结构</title>
      <link>https://lihd2199.github.io/post/linux/linux%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Sun, 05 Sep 2021 21:13:00 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/linux/linux%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB/</guid>
      
        <description>&lt;h2 id=&#34;linux内核结构&#34;&gt;linux内核结构&lt;/h2&gt;
&lt;p&gt;　　承接上文，上文大概的介绍了什么是Linux内核，本节简单介绍一下linux内核的结构，对linux内核有个整体的印象，然后在分模块学习。操作系统是所有应用程序生长的河床，它帮我们屏蔽各种硬件的细节，并且抽象出各种系统调用供应用开发人员来使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/linux%E7%BB%93%E6%9E%84.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个图比较清晰了，是书上的一张图，我们可以看到整个Linux内核可以分为4层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;驱动管理层，驱动并管理外部一些硬件设备，例如磁盘、网卡等。&lt;/li&gt;
&lt;li&gt;工具层，内核抽象出一些通用组件便于自己使用，例如并发管理中的一些锁、per-cpu变量等工具，另外还有中断机制，也给进程管理、信号处理等提供了基础功能。&lt;/li&gt;
&lt;li&gt;系统能力层，操作系统的功能包括进程管理、内存管理、文件系统、I/O管理、网络等，这些功能都是基于工具层和驱动管理层提供的能力来构建的。&lt;/li&gt;
&lt;li&gt;系统调用接口层（syscall），给应用程序开发人员提供相关接口。因为系统调用的使用成本较高，参数也比较多，需要对内核有较多了解，所以，又抽象出一些libc等库函数来封装系统调用，应用开发人员一般都是通过libc等库来与内核打交道的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　我们接下来会把重点放在工具层和系统能力层。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>linux内核前言（一）什么是linux内核</title>
      <link>https://lihd2199.github.io/post/linux/%E4%BB%80%E4%B9%88%E6%98%AFlinux%E5%86%85%E6%A0%B8/</link>
      <pubDate>Sat, 04 Sep 2021 19:21:00 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/linux/%E4%BB%80%E4%B9%88%E6%98%AFlinux%E5%86%85%E6%A0%B8/</guid>
      
        <description>&lt;p&gt;　　最近在工作中学习中总数听人说Linux内核，自己又总是听不懂；另外之前面试也经常被问到，synchronize的内核态和用户态切换，volatile的底层实现，redis的多路复用，这些也都和linux内核有关，所以打算自己学习学习；&lt;/p&gt;
&lt;p&gt;　　常见能搜到的书籍里面《Linux内核深度解析》，《Linux内核设计的艺术》，《操作系统导论》，大概都看过几眼，感觉书里的内容都很细，需要比较好的Linux基础，另外还有很多Linux的代码，对于目前的我不老合适，有点看不懂也有点看不下去。这个时候就需要我们的GitHub了，在GitHub上搜到了&lt;a href=&#34;https://github.com/0voice/linux_kernel_wiki&#34;&gt;linux内核学习资料&lt;/a&gt;，看起来很不错，在一定的高度整体的去看Linux相关知识，高屋建瓴，大家喜欢的可以去给颗星星。这个目录下面的东西很多时候参照这个GitHub上的内容完成的，大家可以直接看这个GitHub。&lt;/p&gt;
&lt;p&gt;　　让我们看看维基百科对Linux内核的定义：&lt;strong&gt;Linux内核&lt;/strong&gt;（英语：Linux kernel）是一种开源的类Unix&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&#34;&gt;操作系统&lt;/a&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AE%8F%E5%86%85%E6%A0%B8&#34;&gt;宏内核&lt;/a&gt;。整个Linux操作系统家族基于该内核部署在传统计算机平台（如个人计算机和服务器，以Linux发行版的形式和各种嵌入式平台，如路由器、无线接入点、专用小交换机、机顶盒、FTA接收器、智能电视、数字视频录像机、网络附加存储（NAS）等。工作于平板电脑智能手机及智能手表的安卓操作系统同样通过Linux内核提供的服务完成自身功能。尽管于桌面电脑的占用率较低，基于Linux的操作系统统治了几乎从移动设备到主机的其他全部领域。截至2017年11月，世界前500台最强的超级计算机全部使用Linux。&lt;/p&gt;
&lt;p&gt;　　说实话，这个定义很不程序员，我是看不太懂，或者和我想象的定义不太一样。&lt;/p&gt;
&lt;p&gt;　　在网上看到了对内核的一个定义，感觉比较靠谱；&lt;strong&gt;内核是与计算机硬件接口的易替换软件的最低级别。它负责将所有以“用户模式”运行的应用程序连接到物理硬件，并允许服务器的进程使用进程间通信(IPC)彼此获取信息。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核是与计算机硬件接口的易替换软件的最低级别；&lt;/li&gt;
&lt;li&gt;责将所有以“用户模式”运行的应用程序连接到物理硬件；&lt;/li&gt;
&lt;li&gt;允许服务器的进程使用进程间通信(IPC)彼此获取信息；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　根据这个大概有个印象，我们也知道了内核的一些基本功能：进程间的通信、连接硬件等等，还要一些别的功能，之后会有一些深入的研究。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Raft算法</title>
      <link>https://lihd2199.github.io/post/consistency/raft/</link>
      <pubDate>Tue, 31 Aug 2021 10:44:55 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/consistency/raft/</guid>
      
        <description>&lt;p&gt;本文为著名的 RAFT 一致性算法论文的中文翻译&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;　　Raft 是一种用于管理复制日志的共识算法。它产生的效果等价于(multi-)Paxos，和Paxos一样高效，但它的结构与Paxos不同；这使得 Raft 比 Paxos 更容易理解，也为构建实用系统提供了更好的基础。为了增强可理解性，Raft 将共识的关键要素（例如领导者选举、日志复制和安全性）分离，并强制执行更强的一致性以减少必须考虑的状态数量。用户研究的结果表明，Raft 比 Paxos 更容易让学生学习。 Raft 还包含了一种用于更改集群成员的新机制，该机制使用重叠多数（overlapping majorities）来保证安全。&lt;/p&gt;
&lt;h2 id=&#34;1-introduction&#34;&gt;1 Introduction&lt;/h2&gt;
&lt;p&gt;　　共识算法允许许多机器作为一个集群工作，可以在某些机器出现故障时仍然能正常的工作。 因此，它们在构建可靠的大型软件系统方面发挥着关键作用。 Paxos在过去十年主导了共识算法的讨论：大多数共识的实现都基于 Paxos 或受其影响，而 Paxos 已成为用于向学生教授共识的主要工具。&lt;/p&gt;
&lt;p&gt;　　不幸的是，Paxos 非常难以理解，尽管多次尝试使其更易于理解。 此外，其架构需要进行复杂的更改才能支持实际系统。 因此，系统构建者和学生都在为 Paxos 苦苦挣扎。&lt;/p&gt;
&lt;p&gt;　　在自己与Paxos苦苦挣扎之后，我们着手寻找一种新的共识算法，可以为系统构建和教育提供更好的基础。 我们的方法不同寻常，因为我们的主要目标是在稳定性下，能否为实际系统定义一个共识算法，并以比 Paxos 更容易学习的方式来描述它？ 此外，我们希望该算法能够促进对系统构建者至关重要的直觉的发展（ Furthermore, we wanted the algorithm to facilitate the development of intuitions that are essential for system builders.）。 重要的不仅是算法要起作用，而且要清楚它为什么起作用。&lt;/p&gt;
&lt;p&gt;　　这项工作的结果是一种称为 Raft 的共识算法。 在设计 Raft 时，我们应用了特定的技术来提高可理解性，包括分解（Raft 将领导选举、日志复制和安全性模块化）和状态空间缩减（相对于 Paxos，Raft 减少了不确定性程度和服务器之间彼此不一致的方式 ）。 对两所大学的 43 名学生进行的用户研究表明，Raft 比 Paxos 更容易理解：在学习了这两种算法后，相对于Paxos，其中 33 名学生能够更好地回答有关 Raft 的问题。&lt;/p&gt;
&lt;p&gt;　　Raft 在许多方面与现有的共识算法相似（最著名的是 Oki 和 Liskov 的 ViewstampedReplication），但它有几个新颖的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Strong leader:  Raft 使用比其他共识算法更强的领导形式。 例如，log entries 仅从领导者流向其他服务器。 这简化了复制日志的管理，使 Raft 更容易理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leader election: Raft 使用随机计时器来选举领导者。这为共识算法已经需要的心跳增加了少量机制，同时可以简单快速地解决冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Membership changes: Raft 使用了一种新的联合共识方法用于更改集群中服务器，其中两种不同配置的大多数在转换期间重叠。 这允许集群在配置更改期间继续正常运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　无论是出于教育目的还是作为实现的基础，我们相信 Raft 优于 Paxos 和其他共识算法。Raft 比其他算法更简单易懂；它的描述足够完整，可以满足实际系统的需要； 它有几个开源实现，被多家公司使用； 其安全特性已被正式证明； 其效率可与其他算法相媲美。&lt;/p&gt;
&lt;p&gt;　　论文的其余部分介绍了复制状态机问题（第 2 节），讨论了 Paxos 的优缺点（第 3 节），描述了我们实现可理解性的一般方法（第 4 节），介绍了 Raft 共识算法（第 5 节– 第 7 节)，评估 Raft（第 8 节），并讨论相关工作（第 9 节）。 由于篇幅限制，这里省略了 Raft 算法的一些元素，但可以在扩展的技术报告中找到它们 。 附加材料描述了客户端如何与系统交互，以及如何回收 Raft 日志中的空间。&lt;/p&gt;
&lt;h2 id=&#34;2-replicated-state-machines&#34;&gt;2 Replicated state machines&lt;/h2&gt;
&lt;p&gt;　　一致性算法是在复制状态机的背景下产生的。 在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使某些服务器出现故障也可以继续运行。 复制状态机用于解决分布式系统中的各种容错问题。 例如，具有单个集群领导者的大型系统，如 GFS、HDFS 和 RAMCloud，通常使用单独的复制状态机来进行 leader 选举和存储 leader 崩溃后重新选举需要的配置信息。 复制状态机的例子包括 Chubby 和 ZooKeeper。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../../img/%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA.png&#34;&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6%E6%9C%BA.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　图 1：复制状态机架构&lt;/p&gt;
&lt;p&gt;　　复制状态机通常使用复制日志来实现，如图 1 所示。每个服务器存储一个包含一系列命令的日志，其状态机按顺序执行这些命令。 每个日志以相同的顺序包含相同的命令，因此每个状态机处理相同的命令序列。 这样就能得到相同的状态和相同的输出序列。&lt;/p&gt;
&lt;p&gt;　　一致性算法的工作就是保持复制日志的一致性。 服务器接收来自客户端的命令并将它们添加到其日志中。 它与其他服务器通信，以确保即使某些服务器出现故障，每个日志最终包含相同顺序的相同请求。 一旦命令被正确复制，每个服务器就会按日志顺序处理它们，并将输出返回给客户端。 因此，服务器形成了一个单一的、高度可靠的状态机。&lt;/p&gt;
&lt;p&gt;实际系统的共识算法通常具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它们在所有非&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98&#34;&gt;&lt;!-- raw HTML omitted --&gt;拜占庭条件&lt;!-- raw HTML omitted --&gt;&lt;/a&gt;下确保安全（不返回错误结果），包括网络延迟、分区和丢包、重复和重新排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要大多数服务器都可以运行，并且可以相互之间通信，同时可以和客户端通信，它们就完全可以发挥作用（可用）。 因此，一个典型的五台服务器集群可以容忍任意两台服务器的故障。 假设服务器因故障停止，他们稍后可能会从稳定存储的状态中恢复并重新加入集群。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它们不依赖于时钟来确保日志的一致性，错误的时钟和极端的消息延迟在最坏的情况下会导致可用性问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一般情况下，只要集群的大部分响应了一轮远程过程调用，命令就可以完成。 少数慢速服务器不影响整体系统性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-whats-wrong-with-paxos&#34;&gt;3 What’s wrong with Paxos?&lt;/h2&gt;
&lt;p&gt;　　在过去十年中，Leslie Lamport 的 Paxos 协议几乎成为共识算法的同义词：它是课程中最常教授的协议，大多数共识的实现都以它为起点。 Paxos 首先定义了一个能够就单个决策达成一致的协议，例如单个复制的日志条目。 我们将这个子集称为single-decree Paxos。 然后 Paxos 组合该协议的多个实例以促进一系列决策，例如日志（multi-Paxos）。 Paxos 确保安全性和稳定性，并且支持集群成员的更改。 其正确性已被证明，在一般情况下是有效的。&lt;/p&gt;
&lt;p&gt;　　不幸的是，Paxos 有两个明显的缺点。 第一个缺点是 Paxos 异常难以理解。 众所周知，Paxos完整的解释是不透明的。付出巨大的努力，但是很少有人能够成功地理解它。 因此，有几次尝试用更简单的术语来解释 Paxos。 这些解释侧重于single-decree Paxos，但它们仍然具有挑战性。 在 NSDI 2012 对 atten dees 的非正式调查中，我们发现很少有人对 Paxos 感到满意，即使在经验丰富的研究人员中也是如此。 我们自己也在与 Paxos 斗争； 在阅读了一些简化的解释并设计了我们自己的替代协议之后，我们才能够理解完整的协议，这个过程花了将近一年的时间。&lt;/p&gt;
&lt;p&gt;　　我们假设 Paxos 的不透明性源于它选择单一法令子集作为其基础。 单令Paxos密集而微妙：它分为两个阶段，没有简单直观的解释，不能独立理解。 因此，很难对单一法令协议的工作原理产生直觉。 多 Paxos 的组合规则显着增加了复杂性和微妙性。 我们认为，就多个决策（即日志而不是单个条目）达成共识的整体问题可以用其他更直接、更明显的方式进行分解。&lt;/p&gt;
&lt;h2 id=&#34;4-designing-for-understandability&#34;&gt;4 Designing for understandability&lt;/h2&gt;
&lt;p&gt;　　我们在设计 Raft 时有几个目标：它必须为系统构建提供完整且实用的基础，从而显著的减少开发人员所需的设计工作量； 它必须在所有条件下都是安全的，并且在常规的操作条件下可用； 并且它必须对常见操作有效。 但我们最重要的目标，也是最困难的挑战——可理解性。 必须让大量观众轻松地理解算法。 此外，必须能够对算法产生直觉，以便系统构建者可以在现实世界的实现中进行不可避免的扩展。（so that system builders can make the extensions that are inevitable in real-world implementations.）&lt;/p&gt;
&lt;p&gt;　　在 Raft 的设计中有很多地方我们不得不在替代方法中进行选择。 在这些情况下，我们根据可理解性评估了备选方案：解释每个备选方案有多难（例如，它的状态空间有多复杂，是否有微妙的含义？），以及对读者来说有多容易 完全理解该方法及其含义？&lt;/p&gt;
&lt;p&gt;　　我们认识到这种分析具有高度的主观性；尽管如此，我们还是使用了两种普遍适用的技术。第一种技术是众所周知的问题分解方法：只要有可能，我们将问题分成可以相对独立地解决、解释和理解的单独部分。例如，在 Raft 中，我们将leader election， log replication， safety，和 membership changes分开。&lt;/p&gt;
&lt;p&gt;　　我们的第二种方法是通过减少要考虑的状态数量来简化状态空间，使系统更加连贯并尽可能消除不确定性。具体来说，日志是不允许有漏洞的，Raft 限制了日志彼此不一致的方式。尽管在大多数情况下我们试图消除不确定性，但在某些情况下，不确定性实际上在改善可稳定性。特别是，随机方法引入了不确定性，但它们倾向于通过以类似的方式处理所有可能的选择来减少状态空间（“选择任何一个；无关紧要”）。我们使用随机化来简化 Raft leader 选举算法。&lt;/p&gt;
&lt;p&gt;//todo 后续补上&lt;/p&gt;
&lt;h2 id=&#34;5-the-raft-consensus-algorithm&#34;&gt;5 The Raft consensus algorithm&lt;/h2&gt;
&lt;p&gt;　　Raft 是一种用于管理第 2 节中描述的复制日志的算法。图 2 总结了该算法以供参考，图 3 列出了该算法的关键特性；这些图的元素将在本节的其余部分逐个讨论。&lt;/p&gt;
&lt;p&gt;　　Raft 通过首先选举一个leader来实现共识，然后让leader完全负责管理复制日志。 leader接受来自客户端的日志条目，将它们复制到其他服务器上，并告诉服务器何时将日志条目应用到它们的状态机是安全的。 拥有leader简化了复制日志的管理。 例如，leader可以决定在日志中放置新条目的位置，而无需咨询其他服务器，并且数据以简单的方式从leader流向其他服务器。 leader可能会失败或与其他服务器断开连接，在这种情况下会选出新的leader。&lt;/p&gt;
&lt;p&gt;　　鉴于领导者方法，Raft 将共识问题分解为三个相对独立的子问题，这些子问题将在以下小节中讨论：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; • Leader election:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　当现有Leader失败时，必须选择新Leader（第 5.2 节）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; •Log replication:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　Leader必须接受来自客户端的日志条目并在集群中复制它们，迫使其他节点和自己的日志一致（第 5.3 节）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; •Safety:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　Raft 的关键安全属性是图 3 中的状态机安全属性：如果任何服务器已将特定日志条目应用到其状态机，则其他服务器不能对相同的日志索引应用不同的命令。 5.4 节描述了 Raft 如何确保这个属性； 该解决方案涉及对第 5.2 节中描述的选举机制的额外限制。&lt;/p&gt;
&lt;p&gt;在介绍了共识算法之后，本节讨论了可用性问题和时序在系统中的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;—————图2下—————
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;state&#34;&gt;state&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在所有服务器上持久存在的（在响应远程过程调用 RPC 之前稳定存储的）:　&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;currentTerm&lt;/td&gt;
&lt;td&gt;服务器最后知道的任期（初始化时从０开始递增）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;votedFor&lt;/td&gt;
&lt;td&gt;在当前任期内收到选票的 Candidate id（如果没有就为 null）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;log[]&lt;/td&gt;
&lt;td&gt;日志条目; 每个条目包含状态机的命令和从leader处接收到的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;在所有服务器上部位定存在的:&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;commitIndex&lt;/td&gt;
&lt;td&gt;已知提交的最高的日志条目的索引（初始化为 0，单调增加）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lastApplied&lt;/td&gt;
&lt;td&gt;复制到状态机的最高日志条目的索引（初始化为 0，单调增加）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;leader的不稳定状态（选举后重新初始化）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;nextIndex[]&lt;/td&gt;
&lt;td&gt;对于每个服务器，要发送到该服务器的下一个日志条目的索引（初始化为leader最后一个日志索引 + 1）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;matchIndex[]&lt;/td&gt;
&lt;td&gt;对于每个服务器，已知在服务器上复制的最高日志条目的索引（初始化为0，单调递增）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;appendentries-rpc&#34;&gt;AppendEntries RPC&lt;/h4&gt;
&lt;p&gt;由leader调用以复制日志条目（第 5.3 节）； 也用作心跳（第 5.2 节）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;term&lt;/td&gt;
&lt;td&gt;leader’s 任期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leaderId&lt;/td&gt;
&lt;td&gt;Leader 的 id，为了其他服务器能重定向到客户端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;prevLogIndex&lt;/td&gt;
&lt;td&gt;紧接在新条目之前的日志条目的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;prevLogTerm&lt;/td&gt;
&lt;td&gt;上一个日志的所在任期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entries[]&lt;/td&gt;
&lt;td&gt;要存储的日志条目（为空的时候代表心跳；为了效率可以发送多个）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leaderCommit&lt;/td&gt;
&lt;td&gt;leader’s commitIndex&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;响应&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;term&lt;/td&gt;
&lt;td&gt;currentTerm, for leader to update itself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;success&lt;/td&gt;
&lt;td&gt;如果 follower 包含匹配prevLogIndex 和 prevLogTerm 的 log entry  返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;follower的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;如果 term &amp;lt; currentTerm (第 5.1 节)，则回复 false&lt;/li&gt;
&lt;li&gt;如果日志在 prevLogIndex 中不包含与 prevLogTerm 匹配的条目，则回复 false（第 5.3 节）&lt;/li&gt;
&lt;li&gt;如果现有条目与新条目冲突（相同的索引但不同的内容），删除现有条目及其后的所有条目（第 5.3 节）&lt;/li&gt;
&lt;li&gt;追加尚未出现在日志中的新条目&lt;/li&gt;
&lt;li&gt;如果leaderCommit &amp;gt; commitIndex，设置commitIndex =min(leaderCommit, index of last new entry)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;requestvote-rpc&#34;&gt;RequestVote RPC&lt;/h4&gt;
&lt;p&gt;由candidates调用以收集选票（第 5.2 节）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;term&lt;/td&gt;
&lt;td&gt;candidate’s term&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;candidateId&lt;/td&gt;
&lt;td&gt;candidate requesting vote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lastLogIndex&lt;/td&gt;
&lt;td&gt;candidate最后一个日志条目的索引（第 5.4 节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lastLogTerm&lt;/td&gt;
&lt;td&gt;candidate最后一个日志条目的任期（第 5.4 节）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;响应&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;term&lt;/td&gt;
&lt;td&gt;当前的任期号，用于 Candidate 更新自己的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;voteGranted&lt;/td&gt;
&lt;td&gt;如果 Candidate 收到选票为 true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;Receiver implementation:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;返回 false 如果 term &amp;lt; currentTerm (第 5.1 节)&lt;/li&gt;
&lt;li&gt;如果votedFor为空或者与candidateId相同，并且 Candidate 的日志和自己的日志一样新，则给该 Candidate 投票（5.2节 和 5.4节）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;rules-for-servers&#34;&gt;Rules for Servers&lt;/h4&gt;
&lt;h5 id=&#34;all-servers&#34;&gt;All Servers:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;如果 commitIndex &amp;gt; lastApplied：增加 lastApplied，将 log[lastApplied] 应用到状态机（第 5.3 节）&lt;/li&gt;
&lt;li&gt;如果 RPC 请求或响应包 term T &amp;gt; currentTerm：设置 currentTerm = T，转换为follower（第 5.1 节）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;followers第-52-节&#34;&gt;Followers:（第 5.2 节）&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Respond to RPCs from candidates and leaders&lt;/li&gt;
&lt;li&gt;如果在超过选取时间之前没有收到来自当前领导人的&lt;code&gt;AppendEntries RPC&lt;/code&gt;或者没有收到候选人的投票请求，则自己转换状态为候选人&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;candidates第-52-节&#34;&gt;Candidates:（第 5.2 节）&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;转换为候选人后，开始选举：
&lt;ul&gt;
&lt;li&gt;currentTerm + 1&lt;/li&gt;
&lt;li&gt;投票给自己&lt;/li&gt;
&lt;li&gt;重置选举计时器&lt;/li&gt;
&lt;li&gt;发送 RequestVote RPCs给其他服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果从大多数服务收到选票，成为leader&lt;/li&gt;
&lt;li&gt;如果从新的leader收到 AppendEntries RPC，变成follower&lt;/li&gt;
&lt;li&gt;如果选举超时，开启新一轮选举&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;leaders&#34;&gt;Leaders：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;选举后：发送空的AppendEntries RPCs (heartbeat)给每台服务器，在空闲期间重复以防止其他服务器超时选举（第 5.2 节）&lt;/li&gt;
&lt;li&gt;如果从客户端收到命令，将entry附加到本地日志，在状态机后之后响应应用entry（第 5.3 节）&lt;/li&gt;
&lt;li&gt;如果对于某个follower  最后的 log index ≥ nextIndex ，那么发送从 nextIndex 开始的所有日志条目：
&lt;ul&gt;
&lt;li&gt;如果成功：更新相应跟随者的 follower 和 matchIndex（第 5.3 节）&lt;/li&gt;
&lt;li&gt;如果因为日志不一致而失败，减少 nextIndex 重试（第 5.3 节）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;假设存在大于 &lt;code&gt;commitIndex&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt;，使得大多数的 &lt;code&gt;matchIndex[i] ≥ N&lt;/code&gt; 成立，且 &lt;code&gt;log[N].term == currentTerm&lt;/code&gt; 成立，则令 &lt;code&gt;commitIndex&lt;/code&gt; 等于 &lt;code&gt;N&lt;/code&gt; （5.3 和 5.4 节）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图2：以上是Raft 共识算法的简要总结（不包括成员变更和日志压缩）。（上面一大段其实是张图）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;—————图2上—————
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;—————图3下—————
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Election Safety: 在给定的任期内最多可以选举一个leader。（第 5.2 节）&lt;/li&gt;
&lt;li&gt;Leader Append-Only: leader从不覆盖或删除其日志中的条目； 它只附加新条目。（第 5.3 节）&lt;/li&gt;
&lt;li&gt;Log Matching:如果两个日志包含具有相同索引和术语的条目，则日志在给定索引之前的所有条目中都是相同的。（第 5.3 节）&lt;/li&gt;
&lt;li&gt;Leader Completeness: 如果在给定的任期内提交了一个日志条目，那么该条目将出现在所有更高编号任期的leader的日志中。（第 5.4 节）&lt;/li&gt;
&lt;li&gt;State Machine Safety:如果服务器已将给定索引处的日志条目应用于其状态机，则其他服务器将永远不会为同一索引应用不同的日志条目。第 5.4.3 节）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;—————图3上—————
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;51-raft-basics&#34;&gt;5.1 Raft basics&lt;/h3&gt;
&lt;p&gt;　　Raft 通过首先选举一个特殊的领导者来实现共识，然后让领导者完全负责管理复制日志。领导者接受来自客户端的日志条目，将它们复制到其他服务器上，并告诉服务器何时将日志条目应用到它们的状态机是安全的。拥有领导者简化了复制日志的管理。例如，领导者可以决定在日志中放置新条目的位置，而无需咨询其他服务器，并且数据以简单的方式从领导者流向其他服务器。领导者可能会失败或与其他服务器断开连接，在这种情况下会选出新的领导者。&lt;/p&gt;
&lt;p&gt;　　鉴于领导者方法，Raft 将共识问题分解为三个相对独立的子问题，这些子问题将在以下小节中讨论：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14.pdf&#34;&gt;raft-论文原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://thesecretlivesofdata.com/raft/&#34;&gt;动画演示&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>http</title>
      <link>https://lihd2199.github.io/post/network/http/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/http/</guid>
      
        <description>&lt;p&gt;HTTP 超文本传输协议是位于 TCP/IP 体系结构中的应用层协议，它是万维网数据通信的基础。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 是目前使用最广泛的版本，一般没有特别标明版本都是指 HTTP/1.1。&lt;/p&gt;
&lt;p&gt;HTTP 报文由请求行、首部、实体主体组成，它们之间由 CRLF（回车换行符） 分隔开。&lt;/p&gt;
&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;
&lt;p&gt;HTTPS 是最流行的 HTTP 安全形式，由网景公司首创，所有主要的浏览器和服务器都支持此协议。 使用 HTTPS 时，所有的 HTTP 请求和响应数据在发送之前，都要进行加密。加密可以使用 SSL 或 TLS。&lt;/p&gt;
&lt;p&gt;SSL/TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送/接收数据流程不变，这就很好地兼容了老的 HTTP 协议。&lt;/p&gt;
&lt;h3 id=&#34;http11-的问题&#34;&gt;HTTP/1.1 的问题&lt;/h3&gt;
&lt;h4 id=&#34;1-队头阻塞&#34;&gt;1. 队头阻塞&lt;/h4&gt;
&lt;p&gt;在 HTTP 请求应答过程中，如果出现了某种情况，导致响应一直未能完成，那后面所有的请求就会一直阻塞着，这种情况叫队头阻塞。&lt;/p&gt;
&lt;h4 id=&#34;2-低效的-tcp-利用&#34;&gt;2. 低效的 TCP 利用&lt;/h4&gt;
&lt;p&gt;每个 TCP 连接在一开始的时候传输速率都不高，在处理多个请求后，才会慢慢达到“合适”的速率。对于请求数据量很小的 HTTP 请求来说，这种情况就是种灾难。&lt;/p&gt;
&lt;h4 id=&#34;3-臃肿的消息首部&#34;&gt;3. 臃肿的消息首部&lt;/h4&gt;
&lt;p&gt;HTTP/1.1 的首部无法压缩，再加上 cookie 的存在，经常会出现首部大小比请求数据大小还大的情况。&lt;/p&gt;
&lt;h4 id=&#34;4-受限的优先级设置&#34;&gt;4. 受限的优先级设置&lt;/h4&gt;
&lt;p&gt;HTTP/1.1 无法为重要的资源指定优先级，每个 HTTP 请求都是一视同仁。&lt;/p&gt;
&lt;h2 id=&#34;http2&#34;&gt;HTTP/2&lt;/h2&gt;
&lt;h4 id=&#34;二进制分帧&#34;&gt;&lt;strong&gt;二进制分帧&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;先来理解几个概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;帧&lt;/strong&gt;：HTTP/2数据通信的最小单位。消息：指 HTTP/2 中逻辑上的 HTTP 消息，例如请求和响应等，消息由一个或多个帧组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流&lt;/strong&gt;：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。&lt;/p&gt;
&lt;p&gt;HTTP/2采用&lt;strong&gt;二进制格式&lt;/strong&gt;传输数据，而非HTTP1.x的文本格式，二进制协议解析起来更高效。&lt;/p&gt;
&lt;p&gt;HTTP/2 是基于帧的协议。采用分帧是为了将重要信息封装起来，让协议的解析方可以轻松阅读、解析并还原信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流&lt;/strong&gt;。 每个数据流都以消息的形式发送，而消息又由一个或多个帧组成,多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。&lt;/p&gt;
&lt;h4 id=&#34;多路复用&#34;&gt;&lt;strong&gt;多路复用&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;多路复用，代替原来的序列和阻塞机制, 所有请求都是通过一个TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个TCP连接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP连接请求限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同个域名只需要占用一个 TCP 连接&lt;/strong&gt;，消除了因多个 TCP 连接而带来的延时和内存消耗。&lt;/p&gt;
&lt;p&gt;•单个连接上可以并行交错的请求和响应，之间互不干扰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;服务器推送&#34;&gt;&lt;strong&gt;服务器推送&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。 例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。&lt;/p&gt;
&lt;p&gt;服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。&lt;/p&gt;
&lt;h4 id=&#34;头部压缩&#34;&gt;&lt;strong&gt;头部压缩&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;HTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。&lt;/p&gt;
&lt;p&gt;HTTP/2对消息头采用HPACK(专为http/2头部设计的压缩格式)进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。&lt;/p&gt;
&lt;p&gt;为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1800848&#34;&gt;HTTP HTTPS HTTP1.1 HTTP2 HTTP3 - 云+社区 - 腾讯云 (tencent.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000022662058&#34;&gt;半小时搞懂 HTTP、HTTPS和HTTP2 - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>MySQL事务</title>
      <link>https://lihd2199.github.io/post/datasource/mysql-transaction/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/datasource/mysql-transaction/</guid>
      
        <description>&lt;h3 id=&#34;一事务的基本要素acid&#34;&gt;一、事务的基本要素（ACID）&lt;/h3&gt;
&lt;p&gt;1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。undo log 日志&lt;/p&gt;
&lt;p&gt;2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。&lt;/p&gt;
&lt;p&gt;3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。MVCC和间隙锁&lt;/p&gt;
&lt;p&gt;4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚 redo log。&lt;/p&gt;
&lt;h3 id=&#34;二事务隔离级别&#34;&gt;二、事务隔离级别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事务隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交 ru&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不可重复读 rc&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读 rr&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;三事务的并发问题&#34;&gt;三、事务的并发问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。&lt;/p&gt;
&lt;p&gt;小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四当前读和快照读&#34;&gt;四、当前读和快照读&lt;/h3&gt;
&lt;p&gt;快照读：
一般的 select * from &amp;hellip;. where &amp;hellip; 语句都是快照读
快照读通过mvcc实现
当前读：
当前读，会在搜索的时候加锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from .... where  ... for update
select * from .... where  ... lock in share mode
update .... set .. where ...
delete from. . where ..
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当前读通过 next key lock 避免幻读
如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。&lt;/p&gt;
&lt;h3 id=&#34;五mvcc版本控制&#34;&gt;五、MVCC版本控制&lt;/h3&gt;
&lt;p&gt;1、MVCC：多版本并发控制，是针对快照读的一种不通过锁来保证事务可见性的实现方式，主要是通过Innodb的undo log和一致性试图（read view）实现的。&lt;/p&gt;
&lt;p&gt;2、Mysql会在某一时刻，创建一致性视图（read view实现的），RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；RC隔离级别是在语句开始时刻创建read view的。我理解这个一致性试图是当前活跃的事务的id数组。&lt;/p&gt;
&lt;p&gt;3、undo log 主要是回滚用的，我们知道每次新增或者修改一条数据，都会产生一条undo log，我们可以理解为是历史数据的记录，或者是对当前操作的反向记录。在我们的每条记录中，数据库都会给我们增加三个字段，id、事务id、回滚指针，我们对一条数据的操作，通过回滚指针，会将数据的undo log形成一条数据链。&lt;/p&gt;
&lt;p&gt;4、在我们在遍历undo log链的时候，比较这条undo log链数据的事务id，如果事务id小于记录的最小的事务id，那么这条数据对当前事务是可见的，如果大于记录的最大事务id，那么这条数据对当前事务是不可见的，如果事务id落在了两者之间，那么需要判断是不是被记录了。如果被记录了，说明不可见。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过high/low water mark快速判断：
trx_id &amp;lt; view-&amp;gt;up_limit_id的记录对于当前read view是一定可见的；
trx_id &amp;gt;= view-&amp;gt;low_limit_id的记录对于当前read view是一定不可见的；
如果trx_id落在[up_limit_id, low_limit_id)，需要在活跃读写事务数组查找trx_id是否存在，如果存在，记录对于当前read view是不可见
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;六lbcc基于锁的控制&#34;&gt;六、LBCC基于锁的控制&lt;/h3&gt;
&lt;p&gt;只使用唯一索引查询，并且只锁定一条记录时，innoDB会使用行锁。&lt;/p&gt;
&lt;p&gt;只使用唯一索引查询，但是检索条件是范围检索，或者是唯一检索然而检索结果不存在时，会产生 Next-Key Lock。&lt;/p&gt;
&lt;p&gt;使用普通索引检索时，不管是何种查询，只要加锁，都会产生间隙锁。&lt;/p&gt;
&lt;p&gt;同时使用唯一索引和普通索引时，由于数据行是优先根据普通索引排序，再根据唯一索引排序，所以也会产生间隙锁。&lt;/p&gt;
&lt;p&gt;锁住普通索引，会锁住对应的唯一索引的行。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>tcp</title>
      <link>https://lihd2199.github.io/post/network/tcp/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/tcp/</guid>
      
        <description>&lt;h3 id=&#34;一tcp概述&#34;&gt;一、tcp概述&lt;/h3&gt;
&lt;p&gt;1、&lt;strong&gt;TCP是面向连接的运输层协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、每一条&lt;em&gt;&lt;strong&gt;TCP连接只能有两个端点&lt;/strong&gt;&lt;/em&gt;(endpoint)，每一条TCP连接只能是点对点的（一对一）&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;TCP提供可靠交付的服务，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、TCP提供&lt;strong&gt;全双工通信&lt;/strong&gt;，TCP允许通信双方的应用进程在任何时候都能发送数据&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;面向字节流，TCP中的流(stream)指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/tcp%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;6、TCP连接的端点叫做套接字(socket)或插口，端口号拼接到P地址即构成了套接字，同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。&lt;/p&gt;
&lt;h3 id=&#34;二tcp报文格式&#34;&gt;二、TCP报文格式&lt;/h3&gt;
&lt;p&gt;TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段，一个TCP报文段分为首部和数据两部分。&lt;/p&gt;
&lt;p&gt;TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项。因此&lt;strong&gt;TCP首部的最小长度是20字节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/tcp%E9%A6%96%E9%83%A8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;1、源端口和目的端口 各占2个字节，分别写入源端口号和目的端口号&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;序号占  4字节。序号范围是[0, 2^32 - 1]，共2^32个序号。序号增加到2^32 - 1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是301，而携带的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的名称也叫做“报文段序号”&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、确认号 占4字节，(ack)是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501～700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。请注意，现在的确认号不是501，也不是700，而是701。&lt;/p&gt;
&lt;p&gt;4、数据偏移 占4位，这个字段实际上是指出TCP报文段的首部长度。“数据偏移”的单位是32位字。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度（即选项长度不能超过40字节）&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;确认ACK  仅当ACK = 1时确认号字段才有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;同步SYN  在连接建立时用来同步序号。当SYN = 1而ACK= 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;终止FIN  用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;8、窗口 占2字节。窗口值是[0, 2^16 - 1]之间的整数。窗口指的是 &lt;strong&gt;&lt;!-- raw HTML omitted --&gt;发送本报文段的一方的接收窗口&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;（而不是自己的发送窗口）。&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;。之所以要有这个限制，是因为接收方的数据缓存空间是有限的，总之，窗口值作为接收方让发送方设置其发送窗口的依据&lt;/p&gt;
&lt;h3 id=&#34;三tcp可靠传输&#34;&gt;三、TCP可靠传输&lt;/h3&gt;
&lt;h4 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h4&gt;
&lt;p&gt;发送方A的发送窗口：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg&#34; alt=&#34;滑动窗口&#34;&gt;&lt;/p&gt;
&lt;p&gt;B的接收窗口：B的接收窗口大小是20，在接收窗口外面，到33号为止的数据是已经发送过确认，并且已经交付主机了。因此在B可以不再保留这些数据。接收窗口内的序号（34～53）是允许接收的。B收到了序号为37和38的数据，这些数据没有按序到达，B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是37（即期望收到的序号），而不能是38或39。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送缓存用来暂时存放：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 发送应用程序传送给发送方TCP准备发送的数据；&lt;/p&gt;
&lt;p&gt;(2) TCP已发送出但尚未收到确认的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收缓存用来暂时存放：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 按序到达的、但尚未被接收应用程序读取的数据；&lt;/p&gt;
&lt;p&gt;(2) 未按序到达的数据。&lt;/p&gt;
&lt;h4 id=&#34;超时重传&#34;&gt;超时重传&lt;/h4&gt;
&lt;p&gt;TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段&lt;/p&gt;
&lt;h4 id=&#34;流量控制&#34;&gt;流量控制&lt;/h4&gt;
&lt;p&gt;所谓流量控制(fow control)就是让发送方的发送速率不要太快，要让接收方来得及接收。&lt;/p&gt;
&lt;p&gt;设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口rwnd = 400”（这里rwnd表示receiver window）。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，&lt;strong&gt;TCP的窗口单位是字节，不是报文段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值&lt;/p&gt;
&lt;h4 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h4&gt;
&lt;p&gt;所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。&lt;/p&gt;
&lt;h3 id=&#34;四连接与释放&#34;&gt;四、连接与释放&lt;/h3&gt;
&lt;h4 id=&#34;三次握手&#34;&gt;三次握手&lt;/h4&gt;
&lt;p&gt;1、A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同步位SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN报文段（即SYN = 1的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。&lt;/p&gt;
&lt;p&gt;2、B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack = x + 1，同时也为自己选择一个初始序号seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;ack是确认号，在首部的地方有。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack = y + 1，而自己的序号seq = x + 1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x + 1。这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;滑动窗口&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么A还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h4&gt;
&lt;p&gt;1、A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN置1，其序号seq =u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。&lt;/p&gt;
&lt;p&gt;2、B收到连接释放报文段后即发出确认，确认号是ack = u + 1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。&lt;/p&gt;
&lt;p&gt;3、若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN = 1。现假定B的序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号ack = u + 1。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。&lt;/p&gt;
&lt;p&gt;4、A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack = w + 1，而自己的序号是seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png&#34; alt=&#34;滑动窗口&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>udp</title>
      <link>https://lihd2199.github.io/post/network/udp/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/udp/</guid>
      
        <description>&lt;h4 id=&#34;一概述&#34;&gt;一、概述&lt;/h4&gt;
&lt;p&gt;UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。&lt;/p&gt;
&lt;p&gt;UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。&lt;/p&gt;
&lt;p&gt;UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/udp%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低&lt;/p&gt;
&lt;p&gt;UDP支持一对一、一对多、多对一和多对多的交互通信&lt;/p&gt;
&lt;h3 id=&#34;二udp的首部格式&#34;&gt;二、UDP的首部格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/udp%E9%A6%96%E9%83%A8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;(1) 源端口 源端口号。在需要对方回信时选用。不需要时可用全0。&lt;/p&gt;
&lt;p&gt;(2) 目的端口 目的端口号。这在终点交付报文时必须要使用到。&lt;/p&gt;
&lt;p&gt;(3) 长度 UDP用户数据报的长度，其最小值是8（仅有首部）。&lt;/p&gt;
&lt;p&gt;(4) 检验和 检测UDP用户数据报在传输中是否有错。有错就丢弃。&lt;/p&gt;
&lt;p&gt;UDP用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>加密</title>
      <link>https://lihd2199.github.io/post/network/encryption/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/encryption/</guid>
      
        <description>&lt;h2 id=&#34;加密算法&#34;&gt;加密算法&lt;/h2&gt;
&lt;h4 id=&#34;对称密钥密码体制&#34;&gt;对称密钥密码体制&lt;/h4&gt;
&lt;p&gt;对称密钥密码体制，即加密密钥和解密密钥是使用相同的密码体制。对称密钥加密技术的缺点之一就是发送者和接收者在对话之前，一定要有一个共享的密钥，所以不太安全。&lt;/p&gt;
&lt;h4 id=&#34;公钥密码体制&#34;&gt;公钥密码体制&lt;/h4&gt;
&lt;p&gt;公钥密码体制使用不同的加密密钥与解密密钥。公钥密码体制的产生主要是因为两个方面的原因，一是由于对称密钥密码体制的密钥分配问题，二是由于对数字签名的需求。&lt;/p&gt;
&lt;p&gt;在公钥密码体制中，加密密钥是公开的，解密密钥是需要保密的，加密算法和解密算法也是公开的。&lt;/p&gt;
&lt;p&gt;公钥密码体制的加密和解密有如下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;密钥对产生器产生出接收者 B 的一对密钥，即加密密钥 PK 和解密密钥 SK。&lt;/li&gt;
&lt;li&gt;发送者 A 用 B 的公钥 PK 作为加密密钥来加密信息，B 接收后用解密密钥 SK 解密。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;摘要算法&#34;&gt;摘要算法&lt;/h2&gt;
&lt;p&gt;摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，目前可以被解密逆向的只有CRC32算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。&lt;/p&gt;
&lt;h2 id=&#34;数字签名&#34;&gt;数字签名&lt;/h2&gt;
&lt;p&gt;用加密系统对报文进行签名，以说明是谁编写的报文，同时证明报文未被篡改过，这种技术称为&lt;strong&gt;数字签名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数字签名必须保证能够实现以下三点功能：&lt;/p&gt;
&lt;p&gt;(1) 接收者能够核实发送者对报文的签名。也就是说，接收者能够确信该报文的确是发送者发送的。其他人无法伪造对报文的签名。这就叫做报文鉴别。&lt;/p&gt;
&lt;p&gt;(2) 接收者确信所收到的数据和发送者发送的完全一样而没有被篡改过。这就叫做报文的完整性。&lt;/p&gt;
&lt;p&gt;(3) 发送者事后不能抵赖对报文的签名。这就叫做不可否认。&lt;/p&gt;
&lt;p&gt;为了进行签名，A用其私钥SKA对报文X进行D运算。D运算本来叫做解密运算。还没有加密怎么就进行解密呢？这并没有关系。因为 D 运算只是得到了某种不可读的密文。A把经过D运算得到的密文传送给B。B为了核实签名，用A的公钥进行E运算，还原出明文X。请注意，任何人用A的公钥PKA进行E运算后都可以得出A发送的明文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;数字签名通常是用非对称公开密钥技术产生的。&lt;/p&gt;
&lt;p&gt;数字签名为什么具有上述的三点功能。因为除A外没有别人持有A的私钥SKA，所以除A外没有别人能产生密文[插图]。这样，B就相信报文X是A签名发送的。这就是报文鉴别的功能。同理，其他人如果篡改过报文，但并无法得到A的私钥 SKA来对X进行加密。B对篡改过的报文进行解密后，将会得出不可读的明文，就知道收到的报文被篡改过。这样就保证报文完整性的功能。若A要抵赖曾发送报文给B，B可把X 及[插图]出示给进行公证的第三者。第三者很容易用PKA去证实A确实发送X给B。这就是不可否认的功能。这里的&lt;em&gt;&lt;strong&gt;关键都是没有其他人能够持有A的私钥SKA&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;数字证书&#34;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;假如你想访问一个网站，怎么确保对方给你的公钥是你想访问的网站的公钥，而不是被中间人篡改过的？&lt;/p&gt;
&lt;p&gt;数字证书的出现就是为了解决这个问题，它是由数字证书认证机构颁发的，用来证明公钥拥有者的身份。换句话说，数字证书的作用就相当于人的身份证，身份证证明了张三就是张三，而不是别人。&lt;/p&gt;
&lt;h2 id=&#34;ssltls&#34;&gt;SSL/TLS&lt;/h2&gt;
&lt;p&gt;● 安全套接字层SSL (Secure Socket Layer)&lt;/p&gt;
&lt;p&gt;● 运输层安全TLS (Transport Layer Security)&lt;/p&gt;
&lt;h4 id=&#34;ssl提供的安全服务可归纳为以下三种&#34;&gt;SSL提供的安全服务可归纳为以下三种：&lt;/h4&gt;
&lt;p&gt;(1) SSL服务器鉴别，允许用户证实服务器的身份。支持SSL的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥。&lt;/p&gt;
&lt;p&gt;(2) SSL客户鉴别，SSL的可选安全服务，允许服务器证实客户的身份。&lt;/p&gt;
&lt;p&gt;(3) 加密的SSL会话，对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。&lt;/p&gt;
&lt;h4 id=&#34;ssl的工作过程&#34;&gt;SSL的工作过程&lt;/h4&gt;
&lt;p&gt;(1) 协商加密算法。浏览器A向服务器B发送浏览器的SSL版本号和一些可选的加密算法，B从中选定自己所支持的算法，并告知A。&lt;/p&gt;
&lt;p&gt;(2) 服务器鉴别。服务器B向浏览器A发送一个包含其RSA公钥的数字证书，A使用该证书的认证机构CA的公开发布的RSA公钥对该证书进行验证。&lt;/p&gt;
&lt;p&gt;(3) 会话密钥计算。由浏览器A随机产生一个秘密数，用服务器B的RSA公钥进行加密后发送给B。双方根据协商的算法产生一个共享的对称会话密钥。&lt;/p&gt;
&lt;p&gt;(4) 安全数据传输。双方用会话密钥加密和解密它们之间传送的数据并验证其完整性。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>硬件的常识</title>
      <link>https://lihd2199.github.io/post/network/hard/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/hard/</guid>
      
        <description>&lt;p&gt;(1) 物理层使用的中间设备叫做转发器(repeater)。&lt;/p&gt;
&lt;p&gt;(2) 数据链路层使用的中间设备叫做网桥或桥接器(bridge)。&lt;/p&gt;
&lt;p&gt;(3) 网络层使用的中间设备叫做路由器(router）。&lt;/p&gt;
&lt;p&gt;(4) 在网络层以上使用的中间设备叫做网关(gateway)。用网关连接两个不兼容的系统需要在高层进行协议的转换。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>网络分层模型</title>
      <link>https://lihd2199.github.io/post/network/hierarchical-model/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/hierarchical-model/</guid>
      
        <description>&lt;h2 id=&#34;五层结构&#34;&gt;&lt;strong&gt;五层结构&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;一物理层&#34;&gt;一、物理层&lt;/h3&gt;
&lt;p&gt;在物理层上所传数据的单位是比特。&lt;strong&gt;发送方发送1（或0）时，接收方应当收到1（或0）而不是0（或1）。因此物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特&lt;/strong&gt;。物理层还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。&lt;/p&gt;
&lt;h3 id=&#34;二数据链路层&#34;&gt;二、数据链路层&lt;/h3&gt;
&lt;p&gt;在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。&lt;/p&gt;
&lt;h3 id=&#34;三网络层&#34;&gt;三、网络层&lt;/h3&gt;
&lt;p&gt;网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包(packet)进行传送。&lt;strong&gt;在TCP/IP体系中，网络层使用IP协议，分组也叫作 IP数据报，或简称为数据报(datagram)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。&lt;/p&gt;
&lt;h3 id=&#34;四传输层&#34;&gt;四、传输层&lt;/h3&gt;
&lt;p&gt;运输层的任务就是负责向两个主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。&lt;/p&gt;
&lt;p&gt;运输层主要使用以下两种协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传输控制协议TCP (Transmission Control Protocol)——提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户数据报协议 UDP (User Datagram Protocol)——提供无连接的、尽最大努力(best-effort)的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五-应用层&#34;&gt;五、 应用层&lt;/h3&gt;
&lt;p&gt;应用层的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程间通信和交互的规则。**这里的进程(process)就是指主机中正在运行的程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>网络层</title>
      <link>https://lihd2199.github.io/post/network/network-layer/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/network-layer/</guid>
      
        <description>&lt;h3 id=&#34;一网络层的设计&#34;&gt;一、网络层的设计&lt;/h3&gt;
&lt;p&gt;因特网采用的设计思路是这样的：&lt;strong&gt;网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务&lt;/strong&gt;。网络在发送分组时不需要先建立连接。每一个分组（也就是IP数据报）独立发送，与其前后的分组无关（不进行编号）。&lt;strong&gt;网络层不提供服务质量的承诺&lt;/strong&gt;。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉。&lt;strong&gt;如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;二ip地址与硬件地址&#34;&gt;二、IP地址与硬件地址&lt;/h3&gt;
&lt;p&gt;从层次的角度看，&lt;strong&gt;物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC帧的首部中。&lt;/p&gt;
&lt;p&gt;连接在通信链路上的设备（主机或路由器）在接收MAC帧时，其根据是MAC帧首部中的硬件地址。在数据链路层看不见隐藏在MAC帧的数据中的IP地址。只有在剥去MAC帧的首部和尾部后把MAC层的数据上交给网络层后，网络层才能在IP数据报的首部中找到源IP地址和目的IP地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;三地址解析协议arp&#34;&gt;三、地址解析协议ARP&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ARP协议的用途是为了从网络层使用的IP地址解析出在数据链路层使用的硬件地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络层使用的是IP地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但IP地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系。地址解析协议ARP解决这个问题的方法是&lt;strong&gt;在主机ARP高速缓存中应存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当主机A要向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的硬件地址，再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP, 找出主机B的硬件地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/arp%E5%85%B8%E5%9E%8B%E6%83%85%E5%86%B5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面我们归纳出使用ARP的四种典型情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送方是主机（如H1），要把IP数据报发送到同一个网络上的另一个主机（如H2）。这时H1发送ARP请求分组（在网1上广播），找到目的主机H2的硬件地址。(2)发送方是主机（如H1），要把IP数据报发送到另一个网络上的一个主机（如H3或H4）。这时H1发送ARP请求分组（在网1上广播），找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。&lt;/li&gt;
&lt;li&gt;发送方是主机（如H1），要把IP数据报发送到另一个网络上的一个主机（如H3或H4）。这时H1发送ARP请求分组（在网1上广播），找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。&lt;/li&gt;
&lt;li&gt;发送方是路由器（如R1），要把IP数据报转发到与R1连接在同一个网络（网2）上的主机（如H3）。这时R1发送ARP请求分组（在网2上广播），找到目的主机H3的硬件地址。&lt;/li&gt;
&lt;li&gt;发送方是路由器（如R1），要把IP数据报转发到网3上的一个主机（如H4）。H4与R1不是连接在同一个网络上。这时R1发送ARP请求分组（在网2上广播），找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四ip数据报格式&#34;&gt;四、ip数据报格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/ip%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;(1) 版本 占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4 (即IPv4);&lt;/p&gt;
&lt;p&gt;(2) 首部长度  占4位 ;&lt;/p&gt;
&lt;p&gt;(3) 区分服务 占8位，用来获得更好的服务，但实际上一直没有被使用过;&lt;/p&gt;
&lt;p&gt;(4) 总长度 总长度指首部和数据之和的长度，单位为字节。总长度字段为16位，因此数据报的最大长度为 65 535字节。 然而实际上传送这样长的数据报在现实中是极少遇到的;&lt;/p&gt;
&lt;p&gt;(5) 标识 占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。&lt;/p&gt;
&lt;p&gt;(6) 标志(fag) 占3位，但目前只有两位有意义。&lt;/p&gt;
&lt;p&gt;● 标志字段中的最低位记为MF (MoreFragment)。MF = 1即表示后面还有分片的数据报。MF = 0表示这已是若干数据报片中的最后一个。&lt;/p&gt;
&lt;p&gt;● 标志字段中间的一位记为DF (Don&amp;rsquo;tFragment)，意思是不能分片。只有当DF = 0时才允许分片;&lt;/p&gt;
&lt;p&gt;(7) 片偏移 占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置；&lt;/p&gt;
&lt;p&gt;(8) 生存时间 占8位，生存时间字段常用的英文缩写是TTL (Time To Live)，表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子；&lt;/p&gt;
&lt;p&gt;(9) 协议 占8位，表示该分组携带的数据使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程（如TCP、UDP、ICMP等）。常用的一些协议和相应的协议字段值（写在协议后面的括号中）是：UDP（17）、TCP（6）、ICMP（1）、GGP（3）、EGP（8）、IGP（9）、OSPE（89）&lt;/p&gt;
&lt;h3 id=&#34;五ipv4地址&#34;&gt;五、IPv4地址&lt;/h3&gt;
&lt;p&gt;一个IPv4地址是32位地址，它唯一地并通用地定义了一个连接到Internet上的主机或者路由器。IP地址是连接的地址，不是主机或者路由器的地址，因为如果设备移动到另一个网络，IP地址可能会改变。把IP地址分为A、B、C、D、E共5类，s其中A类、B类和C类是单播地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/ip%E5%88%86%E7%B1%BB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;(1)A类地址第1个字节用作网络号，且最高位为0，这样就只有7可以表示网络号，能够表示的网络号有27=128个，因为全0（即00000000）和全1（即01111111，127）在地址中有特殊用途，&lt;strong&gt;网络号字段为全0的IP地址是个保留地址，意思是“本网络”&lt;/strong&gt;*；*&lt;strong&gt;网络号字段为127保留作为本地软件环回测试本主机之用&lt;/strong&gt;。所以去掉有特殊用途的全0和全1的网络地址，这样，就只能表示126个网络号，范围是1～126。后3个字节用作主机号，有24位可表示主机号，能够表示的主机号有224-2=16777214，约为1600万台主机。这里减2的原因是主机号为全0和全1两种，主机号字段全0表示该IP地址是“本主机”所连接到的单个网络地址，主机号字段全1表示该网络上的所有主机（即广播地址）。IP地址空间共有2^32（4294967296）个地址，整个A类地址空间共有2^31个地址，占有整个IP地址空间的50%。A类IP地址常用于大型的网络。&lt;/p&gt;
&lt;p&gt;(2)B类地址前2个字节用作网络号（即高16位），后2个字节用作主机号。网络号字段中最高位为10，剩下14位可以进行分配。实际上B类网络地址128.0.0.0是不能指派的，而可以指派的B类最小网络地址是128.1.0.0。因此，B类地址的可用网络数为(2^14)-1，即16383。B类地址的每一个网络号上最大主机数是2^16-2，即65 534台主机，这里减2是去掉全0和全1的主机号。整个B类地址空间共约有2^30个地址，占整个IP空间的25%。B类地址通常用于中等规模的网络。&lt;/p&gt;
&lt;p&gt;(3)C类地址前3个字节用作网络号（即高24位），最后1个字节用作主机号，网络号字段中最高位为110，还有21位可以进行分配。但C类网络地址192.0.0.0也是不能指派的，可以指派的C类最小网络地址是192.0.1.0，因此，C类地址的可用网络总数是2^21-1，即2097151。在每一个C类网络地址上最大主机数是2^8-2，即254台主机。整个C类地址空间共有2^29个地址，占整个IP地址的12.5%。C类IP地址通常用于小型的网络。&lt;/p&gt;
&lt;p&gt;(4)D类地址最高位为1110，因此，D类地址的第一个字节为224～239。是多播地址，不识别互联网内的单个接口，但识别接口组。主要是留给因特网体系结构委员会（IAB，Internet Architecture Board）使用的。&lt;/p&gt;
&lt;p&gt;(5)E类地址最高位为11110，因此，E类地址第一个字节为240～255，保留用于科学研究。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;网络类别&lt;/th&gt;
&lt;th&gt;最大可指派网络数&lt;/th&gt;
&lt;th&gt;第一个可指派网络号&lt;/th&gt;
&lt;th&gt;最后可指派网络号&lt;/th&gt;
&lt;th&gt;每个网络最大主机数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;(2^7)-1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;126&lt;/td&gt;
&lt;td&gt;(2^24)-2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;(2^14)-1&lt;/td&gt;
&lt;td&gt;128.1&lt;/td&gt;
&lt;td&gt;191.255&lt;/td&gt;
&lt;td&gt;(2^16)-2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;(2^31)-1&lt;/td&gt;
&lt;td&gt;192.0.1&lt;/td&gt;
&lt;td&gt;223.255.255&lt;/td&gt;
&lt;td&gt;(2^8)-2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;网络号&lt;/th&gt;
&lt;th&gt;主机号&lt;/th&gt;
&lt;th&gt;源地址使用&lt;/th&gt;
&lt;th&gt;目的地址使用&lt;/th&gt;
&lt;th&gt;代表的意思&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;本网络上的本主机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;主机号&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;在本网络上的某个主机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全1&lt;/td&gt;
&lt;td&gt;全1&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;只在本网络上广播&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络号&lt;/td&gt;
&lt;td&gt;全1&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;改网络号上的所有主机广播&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;非全0/全1&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;用作本地软件环回测试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Pv4地址分为A、B、C、D、E五类，出去特殊作用的D、E两类，剩下的A、B、C三类地址是我们常见的IP地址段。A类地址的容量最大，可以容纳16777214个主机，B类地址可以容纳65534个主机，C类地址可以容纳254个主机。&lt;/strong&gt;
&lt;strong&gt;在这三类地址中，绝大多数的IP地址都是公有地址，需要向国际互联网信息中心申请注册。但是在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。&lt;/strong&gt;
&lt;strong&gt;这三个地址段分别位于A、B、C三类地址内：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A类地址：10.0.0.0&amp;ndash;10.255.255.255&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B类地址：172.16.0.0&amp;ndash;172.31.255.255&lt;/strong&gt;*&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C类地址：192.168.0.0&amp;ndash;192.168.255.255&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所以局域网在选取使用私有地址时，一般会按照实际需要容纳的主机数来选择私有地址段。常见的局域网由于容量小，一般选择C类的192.168.0.0作为地址段使用，一些大型企业就需要使用B类甚至A类地址段作为内部网络的地址段。&lt;/strong&gt;
&lt;strong&gt;最后需要补充说明的是，由于NAT和子网掩码的存在，实际在使用中，一个C类大小的局域网也可以选择A类的10.0.0.0网段作为自己的IP地址段。大多数局域网之所以仍然选择192.168.0.0/24或者192.168.1.0/24作为自己的IP地址段，更多的是因为约定成俗或者说网管个人习惯的关系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者：匿名用户&lt;/strong&gt;
&lt;strong&gt;链接：https://www.zhihu.com/question/19813460/answer/13042143&lt;/strong&gt;
&lt;strong&gt;来源：知乎&lt;/strong&gt;
&lt;strong&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;子网划分&#34;&gt;子网划分&lt;/h4&gt;
&lt;p&gt;子网划分是指由网络管理员将本单位一个给定的网络分为若干个更小的部分，这些更小的部分被称为子网。当本单位网络中的主机总数未超出所给定的某类网络可容纳的最大主机数，但单位内部又要划分成若干个分段而便于进行管理时，就可以采用子网划分的方法。为了创建子网，网络管理员需要从原有的两个层次结构的IP 地址的主机位中借出连续的高若干位作为子网络号，后面剩下的仍为主机号字段。于是，原来的&lt;strong&gt;两级层次结构的IP地址在本单位内就变为三级IP地址：网络号、子网号、主机号&lt;/strong&gt;。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>运输层</title>
      <link>https://lihd2199.github.io/post/network/transport-layer/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/transport-layer/</guid>
      
        <description>&lt;h3 id=&#34;一运输层协议&#34;&gt;一、运输层协议&lt;/h3&gt;
&lt;p&gt;运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层；两个主机进行通信就是两个主机中的应用进程互相通信；从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。&lt;/p&gt;
&lt;p&gt;运输层需要有两种不同的运输协议，即面向连接的TCP和无连接的UDP&lt;/p&gt;
&lt;p&gt;UDP在传送数据之前不需要先建立连接。远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。&lt;/p&gt;
&lt;p&gt;TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。&lt;/p&gt;
&lt;h3 id=&#34;二运输层的端口s&#34;&gt;二、运输层的端口s&lt;/h3&gt;
&lt;p&gt;TCP/IP的运输层用一个16位端口号来标志一个端口。16位的端口号可允许有65 535个不同的端口号。&lt;/p&gt;
&lt;h4 id=&#34;服务器端口分类&#34;&gt;服务器端口分类&lt;/h4&gt;
&lt;p&gt;(1) 服务器端使用的端口号这里又分为两类，最重要的一类叫做熟知端口号(well-known port number)或系统端口号，数值为0～1023。另一类叫做登记端口号，数值为1024～49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。&lt;/p&gt;
&lt;p&gt;(2) 客户端使用的端口号 数值为49152～65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>定风波 on 新的一天</title>
    <link>https://lihd2199.github.io/</link>
    <description>Recent content in 定风波 on 新的一天</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 30 Aug 2021 19:47:57 +0800</lastBuildDate>
    
        <atom:link href="https://lihd2199.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>http</title>
      <link>https://lihd2199.github.io/post/network/http/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/http/</guid>
      
        <description>&lt;p&gt;HTTP 超文本传输协议是位于 TCP/IP 体系结构中的应用层协议，它是万维网数据通信的基础。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 是目前使用最广泛的版本，一般没有特别标明版本都是指 HTTP/1.1。&lt;/p&gt;
&lt;p&gt;HTTP 报文由请求行、首部、实体主体组成，它们之间由 CRLF（回车换行符） 分隔开。&lt;/p&gt;
&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;
&lt;p&gt;HTTPS 是最流行的 HTTP 安全形式，由网景公司首创，所有主要的浏览器和服务器都支持此协议。 使用 HTTPS 时，所有的 HTTP 请求和响应数据在发送之前，都要进行加密。加密可以使用 SSL 或 TLS。&lt;/p&gt;
&lt;p&gt;SSL/TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送/接收数据流程不变，这就很好地兼容了老的 HTTP 协议。&lt;/p&gt;
&lt;h3 id=&#34;http11-的问题&#34;&gt;HTTP/1.1 的问题&lt;/h3&gt;
&lt;h4 id=&#34;1-队头阻塞&#34;&gt;1. 队头阻塞&lt;/h4&gt;
&lt;p&gt;在 HTTP 请求应答过程中，如果出现了某种情况，导致响应一直未能完成，那后面所有的请求就会一直阻塞着，这种情况叫队头阻塞。&lt;/p&gt;
&lt;h4 id=&#34;2-低效的-tcp-利用&#34;&gt;2. 低效的 TCP 利用&lt;/h4&gt;
&lt;p&gt;每个 TCP 连接在一开始的时候传输速率都不高，在处理多个请求后，才会慢慢达到“合适”的速率。对于请求数据量很小的 HTTP 请求来说，这种情况就是种灾难。&lt;/p&gt;
&lt;h4 id=&#34;3-臃肿的消息首部&#34;&gt;3. 臃肿的消息首部&lt;/h4&gt;
&lt;p&gt;HTTP/1.1 的首部无法压缩，再加上 cookie 的存在，经常会出现首部大小比请求数据大小还大的情况。&lt;/p&gt;
&lt;h4 id=&#34;4-受限的优先级设置&#34;&gt;4. 受限的优先级设置&lt;/h4&gt;
&lt;p&gt;HTTP/1.1 无法为重要的资源指定优先级，每个 HTTP 请求都是一视同仁。&lt;/p&gt;
&lt;h2 id=&#34;http2&#34;&gt;HTTP/2&lt;/h2&gt;
&lt;h4 id=&#34;二进制分帧&#34;&gt;&lt;strong&gt;二进制分帧&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;先来理解几个概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;帧&lt;/strong&gt;：HTTP/2数据通信的最小单位。消息：指 HTTP/2 中逻辑上的 HTTP 消息，例如请求和响应等，消息由一个或多个帧组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流&lt;/strong&gt;：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。&lt;/p&gt;
&lt;p&gt;HTTP/2采用&lt;strong&gt;二进制格式&lt;/strong&gt;传输数据，而非HTTP1.x的文本格式，二进制协议解析起来更高效。&lt;/p&gt;
&lt;p&gt;HTTP/2 是基于帧的协议。采用分帧是为了将重要信息封装起来，让协议的解析方可以轻松阅读、解析并还原信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流&lt;/strong&gt;。 每个数据流都以消息的形式发送，而消息又由一个或多个帧组成,多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。&lt;/p&gt;
&lt;h4 id=&#34;多路复用&#34;&gt;&lt;strong&gt;多路复用&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;多路复用，代替原来的序列和阻塞机制, 所有请求都是通过一个TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个TCP连接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP连接请求限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同个域名只需要占用一个 TCP 连接&lt;/strong&gt;，消除了因多个 TCP 连接而带来的延时和内存消耗。&lt;/p&gt;
&lt;p&gt;•单个连接上可以并行交错的请求和响应，之间互不干扰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;服务器推送&#34;&gt;&lt;strong&gt;服务器推送&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。 例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。&lt;/p&gt;
&lt;p&gt;服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。&lt;/p&gt;
&lt;h4 id=&#34;头部压缩&#34;&gt;&lt;strong&gt;头部压缩&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;HTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。&lt;/p&gt;
&lt;p&gt;HTTP/2对消息头采用HPACK(专为http/2头部设计的压缩格式)进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。&lt;/p&gt;
&lt;p&gt;为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;•每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1800848&#34;&gt;HTTP HTTPS HTTP1.1 HTTP2 HTTP3 - 云+社区 - 腾讯云 (tencent.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000022662058&#34;&gt;半小时搞懂 HTTP、HTTPS和HTTP2 - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>MySQL事务</title>
      <link>https://lihd2199.github.io/post/datasource/mysql-transaction/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/datasource/mysql-transaction/</guid>
      
        <description>&lt;h3 id=&#34;一事务的基本要素acid&#34;&gt;一、事务的基本要素（ACID）&lt;/h3&gt;
&lt;p&gt;1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。undo log 日志&lt;/p&gt;
&lt;p&gt;2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。&lt;/p&gt;
&lt;p&gt;3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。MVCC和间隙锁&lt;/p&gt;
&lt;p&gt;4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚 redo log。&lt;/p&gt;
&lt;h3 id=&#34;二事务隔离级别&#34;&gt;二、事务隔离级别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事务隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交 ru&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不可重复读 rc&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读 rr&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;三事务的并发问题&#34;&gt;三、事务的并发问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。&lt;/p&gt;
&lt;p&gt;小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四当前读和快照读&#34;&gt;四、当前读和快照读&lt;/h3&gt;
&lt;p&gt;快照读：
一般的 select * from &amp;hellip;. where &amp;hellip; 语句都是快照读
快照读通过mvcc实现
当前读：
当前读，会在搜索的时候加锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from .... where  ... for update
select * from .... where  ... lock in share mode
update .... set .. where ...
delete from. . where ..
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当前读通过 next key lock 避免幻读
如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。&lt;/p&gt;
&lt;h3 id=&#34;五mvcc版本控制&#34;&gt;五、MVCC版本控制&lt;/h3&gt;
&lt;p&gt;1、MVCC：多版本并发控制，是针对快照读的一种不通过锁来保证事务可见性的实现方式，主要是通过Innodb的undo log和一致性试图（read view）实现的。&lt;/p&gt;
&lt;p&gt;2、Mysql会在某一时刻，创建一致性视图（read view实现的），RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；RC隔离级别是在语句开始时刻创建read view的。我理解这个一致性试图是当前活跃的事务的id数组。&lt;/p&gt;
&lt;p&gt;3、undo log 主要是回滚用的，我们知道每次新增或者修改一条数据，都会产生一条undo log，我们可以理解为是历史数据的记录，或者是对当前操作的反向记录。在我们的每条记录中，数据库都会给我们增加三个字段，id、事务id、回滚指针，我们对一条数据的操作，通过回滚指针，会将数据的undo log形成一条数据链。&lt;/p&gt;
&lt;p&gt;4、在我们在遍历undo log链的时候，比较这条undo log链数据的事务id，如果事务id小于记录的最小的事务id，那么这条数据对当前事务是可见的，如果大于记录的最大事务id，那么这条数据对当前事务是不可见的，如果事务id落在了两者之间，那么需要判断是不是被记录了。如果被记录了，说明不可见。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过high/low water mark快速判断：
trx_id &amp;lt; view-&amp;gt;up_limit_id的记录对于当前read view是一定可见的；
trx_id &amp;gt;= view-&amp;gt;low_limit_id的记录对于当前read view是一定不可见的；
如果trx_id落在[up_limit_id, low_limit_id)，需要在活跃读写事务数组查找trx_id是否存在，如果存在，记录对于当前read view是不可见
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;六lbcc基于锁的控制&#34;&gt;六、LBCC基于锁的控制&lt;/h3&gt;
&lt;p&gt;只使用唯一索引查询，并且只锁定一条记录时，innoDB会使用行锁。&lt;/p&gt;
&lt;p&gt;只使用唯一索引查询，但是检索条件是范围检索，或者是唯一检索然而检索结果不存在时，会产生 Next-Key Lock。&lt;/p&gt;
&lt;p&gt;使用普通索引检索时，不管是何种查询，只要加锁，都会产生间隙锁。&lt;/p&gt;
&lt;p&gt;同时使用唯一索引和普通索引时，由于数据行是优先根据普通索引排序，再根据唯一索引排序，所以也会产生间隙锁。&lt;/p&gt;
&lt;p&gt;锁住普通索引，会锁住对应的唯一索引的行。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>tcp</title>
      <link>https://lihd2199.github.io/post/network/tcp/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/tcp/</guid>
      
        <description>&lt;h3 id=&#34;一tcp概述&#34;&gt;一、tcp概述&lt;/h3&gt;
&lt;p&gt;1、&lt;strong&gt;TCP是面向连接的运输层协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、每一条&lt;em&gt;&lt;strong&gt;TCP连接只能有两个端点&lt;/strong&gt;&lt;/em&gt;(endpoint)，每一条TCP连接只能是点对点的（一对一）&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;TCP提供可靠交付的服务，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、TCP提供&lt;strong&gt;全双工通信&lt;/strong&gt;，TCP允许通信双方的应用进程在任何时候都能发送数据&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;面向字节流，TCP中的流(stream)指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/tcp%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;6、TCP连接的端点叫做套接字(socket)或插口，端口号拼接到P地址即构成了套接字，同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。&lt;/p&gt;
&lt;h3 id=&#34;二tcp报文格式&#34;&gt;二、TCP报文格式&lt;/h3&gt;
&lt;p&gt;TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段，一个TCP报文段分为首部和数据两部分。&lt;/p&gt;
&lt;p&gt;TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项。因此&lt;strong&gt;TCP首部的最小长度是20字节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/tcp%E9%A6%96%E9%83%A8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;1、源端口和目的端口 各占2个字节，分别写入源端口号和目的端口号&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;序号占  4字节。序号范围是[0, 2^32 - 1]，共2^32个序号。序号增加到2^32 - 1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是301，而携带的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的名称也叫做“报文段序号”&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、确认号 占4字节，(ack)是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501～700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。请注意，现在的确认号不是501，也不是700，而是701。&lt;/p&gt;
&lt;p&gt;4、数据偏移 占4位，这个字段实际上是指出TCP报文段的首部长度。“数据偏移”的单位是32位字。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度（即选项长度不能超过40字节）&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;确认ACK  仅当ACK = 1时确认号字段才有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;同步SYN  在连接建立时用来同步序号。当SYN = 1而ACK= 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;终止FIN  用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;8、窗口 占2字节。窗口值是[0, 2^16 - 1]之间的整数。窗口指的是 &lt;strong&gt;&lt;!-- raw HTML omitted --&gt;发送本报文段的一方的接收窗口&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;（而不是自己的发送窗口）。&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;。之所以要有这个限制，是因为接收方的数据缓存空间是有限的，总之，窗口值作为接收方让发送方设置其发送窗口的依据&lt;/p&gt;
&lt;h3 id=&#34;三tcp可靠传输&#34;&gt;三、TCP可靠传输&lt;/h3&gt;
&lt;h4 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h4&gt;
&lt;p&gt;发送方A的发送窗口：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg&#34; alt=&#34;滑动窗口&#34;&gt;&lt;/p&gt;
&lt;p&gt;B的接收窗口：B的接收窗口大小是20，在接收窗口外面，到33号为止的数据是已经发送过确认，并且已经交付主机了。因此在B可以不再保留这些数据。接收窗口内的序号（34～53）是允许接收的。B收到了序号为37和38的数据，这些数据没有按序到达，B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是37（即期望收到的序号），而不能是38或39。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送缓存用来暂时存放：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 发送应用程序传送给发送方TCP准备发送的数据；&lt;/p&gt;
&lt;p&gt;(2) TCP已发送出但尚未收到确认的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收缓存用来暂时存放：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 按序到达的、但尚未被接收应用程序读取的数据；&lt;/p&gt;
&lt;p&gt;(2) 未按序到达的数据。&lt;/p&gt;
&lt;h4 id=&#34;超时重传&#34;&gt;超时重传&lt;/h4&gt;
&lt;p&gt;TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段&lt;/p&gt;
&lt;h4 id=&#34;流量控制&#34;&gt;流量控制&lt;/h4&gt;
&lt;p&gt;所谓流量控制(fow control)就是让发送方的发送速率不要太快，要让接收方来得及接收。&lt;/p&gt;
&lt;p&gt;设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口rwnd = 400”（这里rwnd表示receiver window）。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，&lt;strong&gt;TCP的窗口单位是字节，不是报文段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值&lt;/p&gt;
&lt;h4 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h4&gt;
&lt;p&gt;所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。&lt;/p&gt;
&lt;h3 id=&#34;四连接与释放&#34;&gt;四、连接与释放&lt;/h3&gt;
&lt;h4 id=&#34;三次握手&#34;&gt;三次握手&lt;/h4&gt;
&lt;p&gt;1、A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同步位SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN报文段（即SYN = 1的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。&lt;/p&gt;
&lt;p&gt;2、B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack = x + 1，同时也为自己选择一个初始序号seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;ack是确认号，在首部的地方有。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack = y + 1，而自己的序号seq = x + 1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x + 1。这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;滑动窗口&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么A还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h4&gt;
&lt;p&gt;1、A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN置1，其序号seq =u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。&lt;/p&gt;
&lt;p&gt;2、B收到连接释放报文段后即发出确认，确认号是ack = u + 1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。&lt;/p&gt;
&lt;p&gt;3、若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN = 1。现假定B的序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号ack = u + 1。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。&lt;/p&gt;
&lt;p&gt;4、A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack = w + 1，而自己的序号是seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png&#34; alt=&#34;滑动窗口&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>udp</title>
      <link>https://lihd2199.github.io/post/network/udp/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/udp/</guid>
      
        <description>&lt;h4 id=&#34;一概述&#34;&gt;一、概述&lt;/h4&gt;
&lt;p&gt;UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。&lt;/p&gt;
&lt;p&gt;UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。&lt;/p&gt;
&lt;p&gt;UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/udp%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低&lt;/p&gt;
&lt;p&gt;UDP支持一对一、一对多、多对一和多对多的交互通信&lt;/p&gt;
&lt;h3 id=&#34;二udp的首部格式&#34;&gt;二、UDP的首部格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/udp%E9%A6%96%E9%83%A8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;(1) 源端口 源端口号。在需要对方回信时选用。不需要时可用全0。&lt;/p&gt;
&lt;p&gt;(2) 目的端口 目的端口号。这在终点交付报文时必须要使用到。&lt;/p&gt;
&lt;p&gt;(3) 长度 UDP用户数据报的长度，其最小值是8（仅有首部）。&lt;/p&gt;
&lt;p&gt;(4) 检验和 检测UDP用户数据报在传输中是否有错。有错就丢弃。&lt;/p&gt;
&lt;p&gt;UDP用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>加密</title>
      <link>https://lihd2199.github.io/post/network/encryption/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/encryption/</guid>
      
        <description>&lt;h2 id=&#34;加密算法&#34;&gt;加密算法&lt;/h2&gt;
&lt;h4 id=&#34;对称密钥密码体制&#34;&gt;对称密钥密码体制&lt;/h4&gt;
&lt;p&gt;对称密钥密码体制，即加密密钥和解密密钥是使用相同的密码体制。对称密钥加密技术的缺点之一就是发送者和接收者在对话之前，一定要有一个共享的密钥，所以不太安全。&lt;/p&gt;
&lt;h4 id=&#34;公钥密码体制&#34;&gt;公钥密码体制&lt;/h4&gt;
&lt;p&gt;公钥密码体制使用不同的加密密钥与解密密钥。公钥密码体制的产生主要是因为两个方面的原因，一是由于对称密钥密码体制的密钥分配问题，二是由于对数字签名的需求。&lt;/p&gt;
&lt;p&gt;在公钥密码体制中，加密密钥是公开的，解密密钥是需要保密的，加密算法和解密算法也是公开的。&lt;/p&gt;
&lt;p&gt;公钥密码体制的加密和解密有如下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;密钥对产生器产生出接收者 B 的一对密钥，即加密密钥 PK 和解密密钥 SK。&lt;/li&gt;
&lt;li&gt;发送者 A 用 B 的公钥 PK 作为加密密钥来加密信息，B 接收后用解密密钥 SK 解密。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;摘要算法&#34;&gt;摘要算法&lt;/h2&gt;
&lt;p&gt;摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，目前可以被解密逆向的只有CRC32算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。&lt;/p&gt;
&lt;h2 id=&#34;数字签名&#34;&gt;数字签名&lt;/h2&gt;
&lt;p&gt;用加密系统对报文进行签名，以说明是谁编写的报文，同时证明报文未被篡改过，这种技术称为&lt;strong&gt;数字签名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数字签名必须保证能够实现以下三点功能：&lt;/p&gt;
&lt;p&gt;(1) 接收者能够核实发送者对报文的签名。也就是说，接收者能够确信该报文的确是发送者发送的。其他人无法伪造对报文的签名。这就叫做报文鉴别。&lt;/p&gt;
&lt;p&gt;(2) 接收者确信所收到的数据和发送者发送的完全一样而没有被篡改过。这就叫做报文的完整性。&lt;/p&gt;
&lt;p&gt;(3) 发送者事后不能抵赖对报文的签名。这就叫做不可否认。&lt;/p&gt;
&lt;p&gt;为了进行签名，A用其私钥SKA对报文X进行D运算。D运算本来叫做解密运算。还没有加密怎么就进行解密呢？这并没有关系。因为 D 运算只是得到了某种不可读的密文。A把经过D运算得到的密文传送给B。B为了核实签名，用A的公钥进行E运算，还原出明文X。请注意，任何人用A的公钥PKA进行E运算后都可以得出A发送的明文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;数字签名通常是用非对称公开密钥技术产生的。&lt;/p&gt;
&lt;p&gt;数字签名为什么具有上述的三点功能。因为除A外没有别人持有A的私钥SKA，所以除A外没有别人能产生密文[插图]。这样，B就相信报文X是A签名发送的。这就是报文鉴别的功能。同理，其他人如果篡改过报文，但并无法得到A的私钥 SKA来对X进行加密。B对篡改过的报文进行解密后，将会得出不可读的明文，就知道收到的报文被篡改过。这样就保证报文完整性的功能。若A要抵赖曾发送报文给B，B可把X 及[插图]出示给进行公证的第三者。第三者很容易用PKA去证实A确实发送X给B。这就是不可否认的功能。这里的&lt;em&gt;&lt;strong&gt;关键都是没有其他人能够持有A的私钥SKA&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;数字证书&#34;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;假如你想访问一个网站，怎么确保对方给你的公钥是你想访问的网站的公钥，而不是被中间人篡改过的？&lt;/p&gt;
&lt;p&gt;数字证书的出现就是为了解决这个问题，它是由数字证书认证机构颁发的，用来证明公钥拥有者的身份。换句话说，数字证书的作用就相当于人的身份证，身份证证明了张三就是张三，而不是别人。&lt;/p&gt;
&lt;h2 id=&#34;ssltls&#34;&gt;SSL/TLS&lt;/h2&gt;
&lt;p&gt;● 安全套接字层SSL (Secure Socket Layer)&lt;/p&gt;
&lt;p&gt;● 运输层安全TLS (Transport Layer Security)&lt;/p&gt;
&lt;h4 id=&#34;ssl提供的安全服务可归纳为以下三种&#34;&gt;SSL提供的安全服务可归纳为以下三种：&lt;/h4&gt;
&lt;p&gt;(1) SSL服务器鉴别，允许用户证实服务器的身份。支持SSL的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥。&lt;/p&gt;
&lt;p&gt;(2) SSL客户鉴别，SSL的可选安全服务，允许服务器证实客户的身份。&lt;/p&gt;
&lt;p&gt;(3) 加密的SSL会话，对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。&lt;/p&gt;
&lt;h4 id=&#34;ssl的工作过程&#34;&gt;SSL的工作过程&lt;/h4&gt;
&lt;p&gt;(1) 协商加密算法。浏览器A向服务器B发送浏览器的SSL版本号和一些可选的加密算法，B从中选定自己所支持的算法，并告知A。&lt;/p&gt;
&lt;p&gt;(2) 服务器鉴别。服务器B向浏览器A发送一个包含其RSA公钥的数字证书，A使用该证书的认证机构CA的公开发布的RSA公钥对该证书进行验证。&lt;/p&gt;
&lt;p&gt;(3) 会话密钥计算。由浏览器A随机产生一个秘密数，用服务器B的RSA公钥进行加密后发送给B。双方根据协商的算法产生一个共享的对称会话密钥。&lt;/p&gt;
&lt;p&gt;(4) 安全数据传输。双方用会话密钥加密和解密它们之间传送的数据并验证其完整性。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>硬件的常识</title>
      <link>https://lihd2199.github.io/post/network/hard/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/hard/</guid>
      
        <description>&lt;p&gt;(1) 物理层使用的中间设备叫做转发器(repeater)。&lt;/p&gt;
&lt;p&gt;(2) 数据链路层使用的中间设备叫做网桥或桥接器(bridge)。&lt;/p&gt;
&lt;p&gt;(3) 网络层使用的中间设备叫做路由器(router）。&lt;/p&gt;
&lt;p&gt;(4) 在网络层以上使用的中间设备叫做网关(gateway)。用网关连接两个不兼容的系统需要在高层进行协议的转换。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>网络分层模型</title>
      <link>https://lihd2199.github.io/post/network/hierarchical-model/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/hierarchical-model/</guid>
      
        <description>&lt;h2 id=&#34;五层结构&#34;&gt;&lt;strong&gt;五层结构&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;一物理层&#34;&gt;一、物理层&lt;/h3&gt;
&lt;p&gt;在物理层上所传数据的单位是比特。&lt;strong&gt;发送方发送1（或0）时，接收方应当收到1（或0）而不是0（或1）。因此物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特&lt;/strong&gt;。物理层还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。&lt;/p&gt;
&lt;h3 id=&#34;二数据链路层&#34;&gt;二、数据链路层&lt;/h3&gt;
&lt;p&gt;在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。&lt;/p&gt;
&lt;h3 id=&#34;三网络层&#34;&gt;三、网络层&lt;/h3&gt;
&lt;p&gt;网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包(packet)进行传送。&lt;strong&gt;在TCP/IP体系中，网络层使用IP协议，分组也叫作 IP数据报，或简称为数据报(datagram)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。&lt;/p&gt;
&lt;h3 id=&#34;四传输层&#34;&gt;四、传输层&lt;/h3&gt;
&lt;p&gt;运输层的任务就是负责向两个主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。&lt;/p&gt;
&lt;p&gt;运输层主要使用以下两种协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传输控制协议TCP (Transmission Control Protocol)——提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户数据报协议 UDP (User Datagram Protocol)——提供无连接的、尽最大努力(best-effort)的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五-应用层&#34;&gt;五、 应用层&lt;/h3&gt;
&lt;p&gt;应用层的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程间通信和交互的规则。**这里的进程(process)就是指主机中正在运行的程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>网络层</title>
      <link>https://lihd2199.github.io/post/network/network-layer/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/network-layer/</guid>
      
        <description>&lt;h3 id=&#34;一网络层的设计&#34;&gt;一、网络层的设计&lt;/h3&gt;
&lt;p&gt;因特网采用的设计思路是这样的：&lt;strong&gt;网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务&lt;/strong&gt;。网络在发送分组时不需要先建立连接。每一个分组（也就是IP数据报）独立发送，与其前后的分组无关（不进行编号）。&lt;strong&gt;网络层不提供服务质量的承诺&lt;/strong&gt;。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉。&lt;strong&gt;如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;二ip地址与硬件地址&#34;&gt;二、IP地址与硬件地址&lt;/h3&gt;
&lt;p&gt;从层次的角度看，&lt;strong&gt;物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC帧的首部中。&lt;/p&gt;
&lt;p&gt;连接在通信链路上的设备（主机或路由器）在接收MAC帧时，其根据是MAC帧首部中的硬件地址。在数据链路层看不见隐藏在MAC帧的数据中的IP地址。只有在剥去MAC帧的首部和尾部后把MAC层的数据上交给网络层后，网络层才能在IP数据报的首部中找到源IP地址和目的IP地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;三地址解析协议arp&#34;&gt;三、地址解析协议ARP&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ARP协议的用途是为了从网络层使用的IP地址解析出在数据链路层使用的硬件地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络层使用的是IP地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但IP地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系。地址解析协议ARP解决这个问题的方法是&lt;strong&gt;在主机ARP高速缓存中应存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当主机A要向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的硬件地址，再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP, 找出主机B的硬件地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/arp%E5%85%B8%E5%9E%8B%E6%83%85%E5%86%B5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面我们归纳出使用ARP的四种典型情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送方是主机（如H1），要把IP数据报发送到同一个网络上的另一个主机（如H2）。这时H1发送ARP请求分组（在网1上广播），找到目的主机H2的硬件地址。(2)发送方是主机（如H1），要把IP数据报发送到另一个网络上的一个主机（如H3或H4）。这时H1发送ARP请求分组（在网1上广播），找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。&lt;/li&gt;
&lt;li&gt;发送方是主机（如H1），要把IP数据报发送到另一个网络上的一个主机（如H3或H4）。这时H1发送ARP请求分组（在网1上广播），找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。&lt;/li&gt;
&lt;li&gt;发送方是路由器（如R1），要把IP数据报转发到与R1连接在同一个网络（网2）上的主机（如H3）。这时R1发送ARP请求分组（在网2上广播），找到目的主机H3的硬件地址。&lt;/li&gt;
&lt;li&gt;发送方是路由器（如R1），要把IP数据报转发到网3上的一个主机（如H4）。H4与R1不是连接在同一个网络上。这时R1发送ARP请求分组（在网2上广播），找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四ip数据报格式&#34;&gt;四、ip数据报格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/ip%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;(1) 版本 占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4 (即IPv4);&lt;/p&gt;
&lt;p&gt;(2) 首部长度  占4位 ;&lt;/p&gt;
&lt;p&gt;(3) 区分服务 占8位，用来获得更好的服务，但实际上一直没有被使用过;&lt;/p&gt;
&lt;p&gt;(4) 总长度 总长度指首部和数据之和的长度，单位为字节。总长度字段为16位，因此数据报的最大长度为 65 535字节。 然而实际上传送这样长的数据报在现实中是极少遇到的;&lt;/p&gt;
&lt;p&gt;(5) 标识 占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。&lt;/p&gt;
&lt;p&gt;(6) 标志(fag) 占3位，但目前只有两位有意义。&lt;/p&gt;
&lt;p&gt;● 标志字段中的最低位记为MF (MoreFragment)。MF = 1即表示后面还有分片的数据报。MF = 0表示这已是若干数据报片中的最后一个。&lt;/p&gt;
&lt;p&gt;● 标志字段中间的一位记为DF (Don&amp;rsquo;tFragment)，意思是不能分片。只有当DF = 0时才允许分片;&lt;/p&gt;
&lt;p&gt;(7) 片偏移 占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置；&lt;/p&gt;
&lt;p&gt;(8) 生存时间 占8位，生存时间字段常用的英文缩写是TTL (Time To Live)，表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子；&lt;/p&gt;
&lt;p&gt;(9) 协议 占8位，表示该分组携带的数据使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程（如TCP、UDP、ICMP等）。常用的一些协议和相应的协议字段值（写在协议后面的括号中）是：UDP（17）、TCP（6）、ICMP（1）、GGP（3）、EGP（8）、IGP（9）、OSPE（89）&lt;/p&gt;
&lt;h3 id=&#34;五ipv4地址&#34;&gt;五、IPv4地址&lt;/h3&gt;
&lt;p&gt;一个IPv4地址是32位地址，它唯一地并通用地定义了一个连接到Internet上的主机或者路由器。IP地址是连接的地址，不是主机或者路由器的地址，因为如果设备移动到另一个网络，IP地址可能会改变。把IP地址分为A、B、C、D、E共5类，s其中A类、B类和C类是单播地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lihd2199.github.io/img/ip%E5%88%86%E7%B1%BB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;(1)A类地址第1个字节用作网络号，且最高位为0，这样就只有7可以表示网络号，能够表示的网络号有27=128个，因为全0（即00000000）和全1（即01111111，127）在地址中有特殊用途，&lt;strong&gt;网络号字段为全0的IP地址是个保留地址，意思是“本网络”&lt;/strong&gt;*；*&lt;strong&gt;网络号字段为127保留作为本地软件环回测试本主机之用&lt;/strong&gt;。所以去掉有特殊用途的全0和全1的网络地址，这样，就只能表示126个网络号，范围是1～126。后3个字节用作主机号，有24位可表示主机号，能够表示的主机号有224-2=16777214，约为1600万台主机。这里减2的原因是主机号为全0和全1两种，主机号字段全0表示该IP地址是“本主机”所连接到的单个网络地址，主机号字段全1表示该网络上的所有主机（即广播地址）。IP地址空间共有2^32（4294967296）个地址，整个A类地址空间共有2^31个地址，占有整个IP地址空间的50%。A类IP地址常用于大型的网络。&lt;/p&gt;
&lt;p&gt;(2)B类地址前2个字节用作网络号（即高16位），后2个字节用作主机号。网络号字段中最高位为10，剩下14位可以进行分配。实际上B类网络地址128.0.0.0是不能指派的，而可以指派的B类最小网络地址是128.1.0.0。因此，B类地址的可用网络数为(2^14)-1，即16383。B类地址的每一个网络号上最大主机数是2^16-2，即65 534台主机，这里减2是去掉全0和全1的主机号。整个B类地址空间共约有2^30个地址，占整个IP空间的25%。B类地址通常用于中等规模的网络。&lt;/p&gt;
&lt;p&gt;(3)C类地址前3个字节用作网络号（即高24位），最后1个字节用作主机号，网络号字段中最高位为110，还有21位可以进行分配。但C类网络地址192.0.0.0也是不能指派的，可以指派的C类最小网络地址是192.0.1.0，因此，C类地址的可用网络总数是2^21-1，即2097151。在每一个C类网络地址上最大主机数是2^8-2，即254台主机。整个C类地址空间共有2^29个地址，占整个IP地址的12.5%。C类IP地址通常用于小型的网络。&lt;/p&gt;
&lt;p&gt;(4)D类地址最高位为1110，因此，D类地址的第一个字节为224～239。是多播地址，不识别互联网内的单个接口，但识别接口组。主要是留给因特网体系结构委员会（IAB，Internet Architecture Board）使用的。&lt;/p&gt;
&lt;p&gt;(5)E类地址最高位为11110，因此，E类地址第一个字节为240～255，保留用于科学研究。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;网络类别&lt;/th&gt;
&lt;th&gt;最大可指派网络数&lt;/th&gt;
&lt;th&gt;第一个可指派网络号&lt;/th&gt;
&lt;th&gt;最后可指派网络号&lt;/th&gt;
&lt;th&gt;每个网络最大主机数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;(2^7)-1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;126&lt;/td&gt;
&lt;td&gt;(2^24)-2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;(2^14)-1&lt;/td&gt;
&lt;td&gt;128.1&lt;/td&gt;
&lt;td&gt;191.255&lt;/td&gt;
&lt;td&gt;(2^16)-2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;(2^31)-1&lt;/td&gt;
&lt;td&gt;192.0.1&lt;/td&gt;
&lt;td&gt;223.255.255&lt;/td&gt;
&lt;td&gt;(2^8)-2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;网络号&lt;/th&gt;
&lt;th&gt;主机号&lt;/th&gt;
&lt;th&gt;源地址使用&lt;/th&gt;
&lt;th&gt;目的地址使用&lt;/th&gt;
&lt;th&gt;代表的意思&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;本网络上的本主机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;主机号&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;在本网络上的某个主机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全1&lt;/td&gt;
&lt;td&gt;全1&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;只在本网络上广播&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络号&lt;/td&gt;
&lt;td&gt;全1&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;改网络号上的所有主机广播&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;非全0/全1&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;用作本地软件环回测试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Pv4地址分为A、B、C、D、E五类，出去特殊作用的D、E两类，剩下的A、B、C三类地址是我们常见的IP地址段。A类地址的容量最大，可以容纳16777214个主机，B类地址可以容纳65534个主机，C类地址可以容纳254个主机。&lt;/strong&gt;
&lt;strong&gt;在这三类地址中，绝大多数的IP地址都是公有地址，需要向国际互联网信息中心申请注册。但是在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。&lt;/strong&gt;
&lt;strong&gt;这三个地址段分别位于A、B、C三类地址内：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A类地址：10.0.0.0&amp;ndash;10.255.255.255&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B类地址：172.16.0.0&amp;ndash;172.31.255.255&lt;/strong&gt;*&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C类地址：192.168.0.0&amp;ndash;192.168.255.255&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所以局域网在选取使用私有地址时，一般会按照实际需要容纳的主机数来选择私有地址段。常见的局域网由于容量小，一般选择C类的192.168.0.0作为地址段使用，一些大型企业就需要使用B类甚至A类地址段作为内部网络的地址段。&lt;/strong&gt;
&lt;strong&gt;最后需要补充说明的是，由于NAT和子网掩码的存在，实际在使用中，一个C类大小的局域网也可以选择A类的10.0.0.0网段作为自己的IP地址段。大多数局域网之所以仍然选择192.168.0.0/24或者192.168.1.0/24作为自己的IP地址段，更多的是因为约定成俗或者说网管个人习惯的关系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者：匿名用户&lt;/strong&gt;
&lt;strong&gt;链接：https://www.zhihu.com/question/19813460/answer/13042143&lt;/strong&gt;
&lt;strong&gt;来源：知乎&lt;/strong&gt;
&lt;strong&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;子网划分&#34;&gt;子网划分&lt;/h4&gt;
&lt;p&gt;子网划分是指由网络管理员将本单位一个给定的网络分为若干个更小的部分，这些更小的部分被称为子网。当本单位网络中的主机总数未超出所给定的某类网络可容纳的最大主机数，但单位内部又要划分成若干个分段而便于进行管理时，就可以采用子网划分的方法。为了创建子网，网络管理员需要从原有的两个层次结构的IP 地址的主机位中借出连续的高若干位作为子网络号，后面剩下的仍为主机号字段。于是，原来的&lt;strong&gt;两级层次结构的IP地址在本单位内就变为三级IP地址：网络号、子网号、主机号&lt;/strong&gt;。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>运输层</title>
      <link>https://lihd2199.github.io/post/network/transport-layer/</link>
      <pubDate>Mon, 30 Aug 2021 20:27:54 +0800</pubDate>
      
      <guid>https://lihd2199.github.io/post/network/transport-layer/</guid>
      
        <description>&lt;h3 id=&#34;一运输层协议&#34;&gt;一、运输层协议&lt;/h3&gt;
&lt;p&gt;运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层；两个主机进行通信就是两个主机中的应用进程互相通信；从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。&lt;/p&gt;
&lt;p&gt;运输层需要有两种不同的运输协议，即面向连接的TCP和无连接的UDP&lt;/p&gt;
&lt;p&gt;UDP在传送数据之前不需要先建立连接。远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。&lt;/p&gt;
&lt;p&gt;TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。&lt;/p&gt;
&lt;h3 id=&#34;二运输层的端口s&#34;&gt;二、运输层的端口s&lt;/h3&gt;
&lt;p&gt;TCP/IP的运输层用一个16位端口号来标志一个端口。16位的端口号可允许有65 535个不同的端口号。&lt;/p&gt;
&lt;h4 id=&#34;服务器端口分类&#34;&gt;服务器端口分类&lt;/h4&gt;
&lt;p&gt;(1) 服务器端使用的端口号这里又分为两类，最重要的一类叫做熟知端口号(well-known port number)或系统端口号，数值为0～1023。另一类叫做登记端口号，数值为1024～49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。&lt;/p&gt;
&lt;p&gt;(2) 客户端使用的端口号 数值为49152～65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
